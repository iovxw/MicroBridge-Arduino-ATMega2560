   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LVL0:
  14               	.LFB13:
  15               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  **** License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  **** Date:      17 October 2007
  12:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  13:stk500boot.c  **** Compiler:  WINAVR20060421
  14:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  **** DESCRIPTION:
  17:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****     "reset" vector in Application area.
  22:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  23:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  24:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  **** USAGE:
  27:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****     - AVRISP will detect the bootloader
  38:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  **** Note:
  41:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****     Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  **** 	AVRdude:
  46:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  **** NOTES:
  51:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  **** LICENSE:
  55:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****     any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****     GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  **** *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** 
  92:stk500boot.c  **** //************************************************************************
  93:stk500boot.c  **** //*	these are used to test issues
  94:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  95:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  96:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  97:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  98:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  99:stk500boot.c  **** #define	_FIX_ISSUE_505_
 100:stk500boot.c  **** //************************************************************************
 101:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 102:stk500boot.c  **** #define	_FIX_ISSUE_181_
 103:stk500boot.c  **** 
 104:stk500boot.c  **** #include	<inttypes.h>
 105:stk500boot.c  **** #include	<avr/io.h>
 106:stk500boot.c  **** #include	<avr/interrupt.h>
 107:stk500boot.c  **** #include	<avr/boot.h>
 108:stk500boot.c  **** #include	<avr/pgmspace.h>
 109:stk500boot.c  **** #include	<util/delay.h>
 110:stk500boot.c  **** #include	<avr/eeprom.h>
 111:stk500boot.c  **** #include	<avr/common.h>
 112:stk500boot.c  **** #include	<stdlib.h>
 113:stk500boot.c  **** #include	"command.h"
 114:stk500boot.c  **** 
 115:stk500boot.c  **** #include <string.h>
 116:stk500boot.c  **** #include "pff.h"
 117:stk500boot.c  **** 
 118:stk500boot.c  **** void flash_erase (DWORD);				/* Erase a flash page (asmfunc.S) */
 119:stk500boot.c  **** void flash_write (DWORD, const BYTE*);	/* Program a flash page (asmfunc.S) */
 120:stk500boot.c  **** 
 121:stk500boot.c  **** 
 122:stk500boot.c  **** #define BLINK_LED_WHILE_WAITING
 123:stk500boot.c  **** //#define _DEBUG_WITH_LEDS_
 124:stk500boot.c  **** //#define _DEBUG_SERIAL_
 125:stk500boot.c  **** 
 126:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 127:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 128:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 129:stk500boot.c  **** 	#define		ENABLE_MONITOR
 130:stk500boot.c  **** #endif
 131:stk500boot.c  **** 
 132:stk500boot.c  **** #ifndef EEWE
 133:stk500boot.c  **** 	#define EEWE    1
 134:stk500boot.c  **** #endif
 135:stk500boot.c  **** #ifndef EEMWE
 136:stk500boot.c  **** 	#define EEMWE   2
 137:stk500boot.c  **** #endif
 138:stk500boot.c  **** 
 139:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 140:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** /*
 144:stk500boot.c  ****  * Uncomment the following lines to save code space
 145:stk500boot.c  ****  */
 146:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 147:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 148:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 149:stk500boot.c  **** //
 150:stk500boot.c  **** 
 151:stk500boot.c  **** 
 152:stk500boot.c  **** 
 153:stk500boot.c  **** //************************************************************************
 154:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 155:stk500boot.c  **** //*	indicates that bootloader is active
 156:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 157:stk500boot.c  **** //************************************************************************
 158:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 159:stk500boot.c  **** 
 160:stk500boot.c  **** #define PROGLED_PORT	PORTB
 161:stk500boot.c  **** #define PROGLED_DDR		DDRB
 162:stk500boot.c  **** #define PROGLED_PIN		PINB7
 163:stk500boot.c  **** 
 164:stk500boot.c  **** #ifdef _MEGA_BOARD_
 165:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 166:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 167:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 168:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 169:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 170:stk500boot.c  **** 	//*	onbarod led is PORTE4
 171:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 172:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 173:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 174:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 175:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 176:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 177:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 178:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 179:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 180:stk500boot.c  **** #elif defined( _PENGUINO_ )
 181:stk500boot.c  **** 	//*	this is for the Penguino
 182:stk500boot.c  **** 	//*	onbarod led is PORTE4
 183:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 184:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 185:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 186:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 187:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 188:stk500boot.c  **** 	//*	onbarod led is PORTE4
 189:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 190:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 191:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 192:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 193:stk500boot.c  **** 	//*	onbarod led is PORTA7
 194:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 195:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 196:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 197:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 198:stk500boot.c  **** 
 199:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 200:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 201:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 202:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 203:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 204:stk500boot.c  **** 
 205:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 206:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 207:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 208:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 209:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 210:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 211:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 212:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 213:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 214:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 215:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 216:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 217:stk500boot.c  **** #elif defined( _AVRLIP_ )
 218:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 219:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 220:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 221:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 222:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 223:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 224:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 225:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 226:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 227:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 228:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 229:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 230:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 231:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 232:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 233:stk500boot.c  **** #else
 234:stk500boot.c  **** //	#define PROGLED_PORT	PORTG
 235:stk500boot.c  **** //	#define PROGLED_DDR		DDRG
 236:stk500boot.c  **** //	#define PROGLED_PIN		PING2
 237:stk500boot.c  **** #endif
 238:stk500boot.c  **** 
 239:stk500boot.c  **** 
 240:stk500boot.c  **** 
 241:stk500boot.c  **** /*
 242:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 243:stk500boot.c  ****  */
 244:stk500boot.c  **** #ifndef F_CPU
 245:stk500boot.c  **** 	#define F_CPU 16000000UL
 246:stk500boot.c  **** #endif
 247:stk500boot.c  **** 
 248:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 249:stk500boot.c  **** /*
 250:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 251:stk500boot.c  ****  */
 252:stk500boot.c  **** 
 253:stk500boot.c  **** #ifndef BAUDRATE
 254:stk500boot.c  **** 	#define BAUDRATE 115200
 255:stk500boot.c  **** #endif
 256:stk500boot.c  **** 
 257:stk500boot.c  **** /*
 258:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 259:stk500boot.c  ****  */
 260:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 261:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 262:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 263:stk500boot.c  **** 	#else
 264:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 265:stk500boot.c  **** 	#endif
 266:stk500boot.c  **** #endif
 267:stk500boot.c  **** 
 268:stk500boot.c  **** /*
 269:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 270:stk500boot.c  ****  */
 271:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 272:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 273:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 274:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 275:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 276:stk500boot.c  **** 
 277:stk500boot.c  **** /*
 278:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 279:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 280:stk500boot.c  ****  */
 281:stk500boot.c  **** //#define BOOTSIZE 1024
 282:stk500boot.c  **** #if FLASHEND > 0x0F000
 283:stk500boot.c  **** 	#define BOOTSIZE 8192
 284:stk500boot.c  **** #else
 285:stk500boot.c  **** 	#define BOOTSIZE 2048
 286:stk500boot.c  **** #endif
 287:stk500boot.c  **** 
 288:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 289:stk500boot.c  **** 
 290:stk500boot.c  **** /*
 291:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 292:stk500boot.c  ****  */
 293:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 295:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 297:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 299:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 301:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 303:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 305:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 307:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 309:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 310:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 311:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 312:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 313:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 314:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 315:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 316:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 317:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 318:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 319:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 320:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 321:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 322:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 323:stk500boot.c  **** #else
 324:stk500boot.c  **** 	#error "no signature definition for MCU available"
 325:stk500boot.c  **** #endif
 326:stk500boot.c  **** 
 327:stk500boot.c  **** 
 328:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 329:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 330:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 331:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 332:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 333:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 334:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 335:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 336:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 337:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 338:stk500boot.c  **** 
 339:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 340:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 341:stk500boot.c  **** 	/* ATMega8 with one USART */
 342:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 343:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 344:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 345:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 346:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 347:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 348:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 349:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 350:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 351:stk500boot.c  **** 
 352:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 353:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 354:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 355:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 356:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 357:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 358:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 359:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 360:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 361:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 362:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 363:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 364:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 365:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 366:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 367:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 368:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 369:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 370:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 371:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 372:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 373:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 374:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 375:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 376:stk500boot.c  **** 	//* catch all
 377:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 378:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 379:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 380:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 381:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 382:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 383:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 384:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 385:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 386:stk500boot.c  **** #else
 387:stk500boot.c  **** 	#error "no UART definition for MCU available"
 388:stk500boot.c  **** #endif
 389:stk500boot.c  **** 
 390:stk500boot.c  **** 
 391:stk500boot.c  **** 
 392:stk500boot.c  **** /*
 393:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 394:stk500boot.c  ****  */
 395:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 396:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 397:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 398:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 399:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 400:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 401:stk500boot.c  **** #else
 402:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 403:stk500boot.c  **** #endif
 404:stk500boot.c  **** 
 405:stk500boot.c  **** 
 406:stk500boot.c  **** /*
 407:stk500boot.c  ****  * States used in the receive state machine
 408:stk500boot.c  ****  */
 409:stk500boot.c  **** #define	ST_START		0
 410:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 411:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 412:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 413:stk500boot.c  **** #define ST_GET_TOKEN	4
 414:stk500boot.c  **** #define ST_GET_DATA		5
 415:stk500boot.c  **** #define	ST_GET_CHECK	6
 416:stk500boot.c  **** #define	ST_PROCESS		7
 417:stk500boot.c  **** 
 418:stk500boot.c  **** /*
 419:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 420:stk500boot.c  ****  */
 421:stk500boot.c  **** #if defined(RAMPZ)
 422:stk500boot.c  **** 	typedef uint32_t address_t;
 423:stk500boot.c  **** #else
 424:stk500boot.c  **** 	typedef uint16_t address_t;
 425:stk500boot.c  **** #endif
 426:stk500boot.c  **** 
 427:stk500boot.c  **** /*
 428:stk500boot.c  ****  * function prototypes
 429:stk500boot.c  ****  */
 430:stk500boot.c  **** static void sendchar(char c);
 431:stk500boot.c  **** 
 432:stk500boot.c  **** 
 433:stk500boot.c  **** // SDCARD BOOTLOADER
 434:stk500boot.c  **** 
 435:stk500boot.c  **** 
 436:stk500boot.c  **** FATFS Fatfs;				/* Petit-FatFs work area */
 437:stk500boot.c  **** unsigned char Buff[SPM_PAGESIZE];	/* Page data buffer */
 438:stk500boot.c  **** 
 439:stk500boot.c  **** // SDCARD BOOTLOADER
 440:stk500boot.c  **** 
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 
 443:stk500boot.c  **** /*
 444:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 445:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 446:stk500boot.c  ****  */
 447:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 448:stk500boot.c  **** #include <avr/sfr_defs.h>
 449:stk500boot.c  **** 
 450:stk500boot.c  **** //#define	SPH_REG	0x3E
 451:stk500boot.c  **** //#define	SPL_REG	0x3D
 452:stk500boot.c  **** 
 453:stk500boot.c  **** //*****************************************************************************
 454:stk500boot.c  **** void __jumpMain(void)
 455:stk500boot.c  **** {
 456:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 457:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 458:stk500boot.c  **** 
 459:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 460:stk500boot.c  **** 
 461:stk500boot.c  **** //*	set stack pointer to top of RAM
 462:stk500boot.c  **** 
 463:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 464:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 465:stk500boot.c  **** 
 466:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 467:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 468:stk500boot.c  **** 
 469:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 470:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 471:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 472:stk500boot.c  **** }
 473:stk500boot.c  **** 
 474:stk500boot.c  **** 
 475:stk500boot.c  **** //*****************************************************************************
 476:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 477:stk500boot.c  **** {
 478:stk500boot.c  **** 	unsigned int i;
 479:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 480:stk500boot.c  **** 	{
 481:stk500boot.c  **** 		_delay_ms(0.5);
 482:stk500boot.c  **** 	}
 483:stk500boot.c  **** }
 484:stk500boot.c  **** 
 485:stk500boot.c  **** 
 486:stk500boot.c  **** //*****************************************************************************
 487:stk500boot.c  **** /*
 488:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 489:stk500boot.c  ****  */
 490:stk500boot.c  **** static void sendchar(char c)
 491:stk500boot.c  **** {
  16               		.loc 1 491 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 492 2 view .LVU1
  23               		.loc 1 492 16 is_stmt 0 view .LVU2
  24 0000 8093 C600 		sts 198,r24
 493:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  25               		.loc 1 493 2 is_stmt 1 view .LVU3
  26               	.LVL1:
  27               	.L2:
  28               		.loc 1 493 60 discriminator 1 view .LVU4
  29               		.loc 1 493 8 discriminator 1 view .LVU5
  30               		.loc 1 493 11 is_stmt 0 discriminator 1 view .LVU6
  31 0004 8091 C000 		lds r24,192
  32               		.loc 1 493 8 discriminator 1 view .LVU7
  33 0008 86FF      		sbrs r24,6
  34 000a 00C0      		rjmp .L2
 494:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  35               		.loc 1 494 2 is_stmt 1 view .LVU8
  36               		.loc 1 494 18 is_stmt 0 view .LVU9
  37 000c 8091 C000 		lds r24,192
  38 0010 8064      		ori r24,lo8(64)
  39 0012 8093 C000 		sts 192,r24
  40               	.LVL2:
  41               	/* epilogue start */
 495:stk500boot.c  **** }
  42               		.loc 1 495 1 view .LVU10
  43 0016 0895      		ret
  44               		.cfi_endproc
  45               	.LFE13:
  47               		.section	.init9,"ax",@progbits
  48               	.global	__jumpMain
  50               	__jumpMain:
  51               	.LFB11:
 455:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  52               		.loc 1 455 1 is_stmt 1 view -0
  53               		.cfi_startproc
  54               	/* prologue: naked */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
 459:stk500boot.c  **** 
  58               		.loc 1 459 2 view .LVU12
  59               	/* #APP */
  60               	 ;  459 "stk500boot.c" 1
  61               		.set __stack, 8703
  62               	 ;  0 "" 2
 463:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  63               		.loc 1 463 2 view .LVU13
  64               	 ;  463 "stk500boot.c" 1
  65 0000 01E2      		ldi	16, 33
  66               	 ;  0 "" 2
 464:stk500boot.c  **** 
  67               		.loc 1 464 2 view .LVU14
  68               	 ;  464 "stk500boot.c" 1
  69 0002 0EBF      		out 62,16
  70               	 ;  0 "" 2
 466:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  71               		.loc 1 466 2 view .LVU15
  72               	 ;  466 "stk500boot.c" 1
  73 0004 0FEF      		ldi	16, 255
  74               	 ;  0 "" 2
 467:stk500boot.c  **** 
  75               		.loc 1 467 2 view .LVU16
  76               	 ;  467 "stk500boot.c" 1
  77 0006 0DBF      		out 61,16
  78               	 ;  0 "" 2
 469:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  79               		.loc 1 469 2 view .LVU17
  80               	 ;  469 "stk500boot.c" 1
  81 0008 1124      		clr __zero_reg__
  82               	 ;  0 "" 2
 470:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
  83               		.loc 1 470 2 view .LVU18
  84               	 ;  470 "stk500boot.c" 1
  85 000a 1FBE      		out 63, __zero_reg__
  86               	 ;  0 "" 2
 471:stk500boot.c  **** }
  87               		.loc 1 471 2 view .LVU19
  88               	 ;  471 "stk500boot.c" 1
  89 000c 0C94 0000 		jmp main
  90               	 ;  0 "" 2
  91               	/* #NOAPP */
  92               	/* epilogue start */
 472:stk500boot.c  **** 
  93               		.loc 1 472 1 is_stmt 0 view .LVU20
  94               		.cfi_endproc
  95               	.LFE11:
  97               		.text
  98               	.global	delay_ms
 100               	delay_ms:
 101               	.LVL3:
 102               	.LFB12:
 477:stk500boot.c  **** 	unsigned int i;
 103               		.loc 1 477 1 is_stmt 1 view -0
 104               		.cfi_startproc
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 0 */
 108               	.L__stack_usage = 0
 477:stk500boot.c  **** 	unsigned int i;
 109               		.loc 1 477 1 is_stmt 0 view .LVU22
 110 0018 9C01      		movw r18,r24
 478:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 111               		.loc 1 478 2 is_stmt 1 view .LVU23
 479:stk500boot.c  **** 	{
 112               		.loc 1 479 2 view .LVU24
 113               	.LVL4:
 479:stk500boot.c  **** 	{
 114               		.loc 1 479 8 is_stmt 0 view .LVU25
 115 001a 90E0      		ldi r25,0
 116 001c 80E0      		ldi r24,0
 117               	.LVL5:
 118               	.L7:
 479:stk500boot.c  **** 	{
 119               		.loc 1 479 11 is_stmt 1 discriminator 1 view .LVU26
 479:stk500boot.c  **** 	{
 120               		.loc 1 479 2 is_stmt 0 discriminator 1 view .LVU27
 121 001e 8217      		cp r24,r18
 122 0020 9307      		cpc r25,r19
 123 0022 01F4      		brne .L8
 124               	/* epilogue start */
 483:stk500boot.c  **** 
 125               		.loc 1 483 1 view .LVU28
 126 0024 0895      		ret
 127               	.L8:
 481:stk500boot.c  **** 	}
 128               		.loc 1 481 3 is_stmt 1 view .LVU29
 129               	.LVL6:
 130               	.LBB48:
 131               	.LBI48:
 132               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 133               		.loc 2 166 1 view .LVU30
 134               	.LBB49:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 135               		.loc 2 168 2 view .LVU31
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 136               		.loc 2 172 2 view .LVU32
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 137               		.loc 2 173 2 view .LVU33
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 138               		.loc 2 174 2 view .LVU34
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 139               		.loc 2 184 3 view .LVU35
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 140               		.loc 2 187 2 view .LVU36
 141 0026 EFEC      		ldi r30,lo8(1999)
 142 0028 F7E0      		ldi r31,hi8(1999)
 143 002a 3197      	1:	sbiw r30,1
 144 002c 01F4      		brne 1b
 145 002e 00C0      		rjmp .
 146 0030 0000      		nop
 147               	.LVL7:
 148               		.loc 2 187 2 is_stmt 0 view .LVU37
 149               	.LBE49:
 150               	.LBE48:
 479:stk500boot.c  **** 	{
 151               		.loc 1 479 23 is_stmt 1 view .LVU38
 479:stk500boot.c  **** 	{
 152               		.loc 1 479 24 is_stmt 0 view .LVU39
 153 0032 0196      		adiw r24,1
 154               	.LVL8:
 479:stk500boot.c  **** 	{
 155               		.loc 1 479 24 view .LVU40
 156 0034 00C0      		rjmp .L7
 157               		.cfi_endproc
 158               	.LFE12:
 160               		.section	.rodata.str1.1,"aMS",@progbits,1
 161               	.LC0:
 162 0000 6669 726D 		.string	"firmware.bin"
 162      7761 7265 
 162      2E62 696E 
 162      00
 163               		.section	.text.startup,"ax",@progbits
 164               	.global	main
 166               	main:
 167               	.LFB16:
 496:stk500boot.c  **** 
 497:stk500boot.c  **** 
 498:stk500boot.c  **** //************************************************************************
 499:stk500boot.c  **** static int	Serial_Available(void)
 500:stk500boot.c  **** {
 501:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 502:stk500boot.c  **** }
 503:stk500boot.c  **** 
 504:stk500boot.c  **** 
 505:stk500boot.c  **** 
 506:stk500boot.c  **** 
 507:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 508:stk500boot.c  **** //*****************************************************************************
 509:stk500boot.c  **** static unsigned char recchar_timeout(void)
 510:stk500boot.c  **** {
 511:stk500boot.c  **** uint32_t count = 0;
 512:stk500boot.c  **** 
 513:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 514:stk500boot.c  **** 	{
 515:stk500boot.c  **** 		// wait for data
 516:stk500boot.c  **** 		count++;
 517:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 518:stk500boot.c  **** 		{
 519:stk500boot.c  **** 		unsigned int	data;
 520:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 521:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 522:stk500boot.c  **** 		#else
 523:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 524:stk500boot.c  **** 		#endif
 525:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 526:stk500boot.c  **** 			{
 527:stk500boot.c  **** 				asm volatile(
 528:stk500boot.c  **** 						"clr	r30		\n\t"
 529:stk500boot.c  **** 						"clr	r31		\n\t"
 530:stk500boot.c  **** 						"ijmp	\n\t"
 531:stk500boot.c  **** 						);
 532:stk500boot.c  **** 			}
 533:stk500boot.c  **** 			count	=	0;
 534:stk500boot.c  **** 		}
 535:stk500boot.c  **** 	}
 536:stk500boot.c  **** 	return UART_DATA_REG;
 537:stk500boot.c  **** }
 538:stk500boot.c  **** 
 539:stk500boot.c  **** //*	for watch dog timer startup
 540:stk500boot.c  **** void (*app_start)(void) = 0;
 541:stk500boot.c  **** uint8_t check = 1;
 542:stk500boot.c  **** 
 543:stk500boot.c  **** 
 544:stk500boot.c  **** //*****************************************************************************
 545:stk500boot.c  **** int main(void)
 546:stk500boot.c  **** {
 168               		.loc 1 546 1 is_stmt 1 view -0
 169               		.cfi_startproc
 170 0000 CDB7      		in r28,__SP_L__
 171 0002 DEB7      		in r29,__SP_H__
 172               	.LCFI0:
 173               		.cfi_def_cfa_register 28
 174 0004 CF52      		subi r28,47
 175 0006 D140      		sbci r29,1
 176               	.LCFI1:
 177               		.cfi_def_cfa_offset 306
 178 0008 0FB6      		in __tmp_reg__,__SREG__
 179 000a F894      		cli
 180 000c DEBF      		out __SP_H__,r29
 181 000e 0FBE      		out __SREG__,__tmp_reg__
 182 0010 CDBF      		out __SP_L__,r28
 183               	/* prologue: function */
 184               	/* frame size = 303 */
 185               	/* stack size = 303 */
 186               	.L__stack_usage = 303
 547:stk500boot.c  **** 	address_t		address			=	0;
 187               		.loc 1 547 2 view .LVU42
 188               	.LVL9:
 548:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 189               		.loc 1 548 2 view .LVU43
 549:stk500boot.c  **** 	unsigned char	msgParseState;
 190               		.loc 1 549 2 view .LVU44
 550:stk500boot.c  **** 	unsigned int	ii				=	0;
 191               		.loc 1 550 2 view .LVU45
 551:stk500boot.c  **** 	unsigned char	checksum		=	0;
 192               		.loc 1 551 2 view .LVU46
 552:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 193               		.loc 1 552 2 view .LVU47
 553:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 194               		.loc 1 553 2 view .LVU48
 554:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 195               		.loc 1 554 2 view .LVU49
 555:stk500boot.c  **** 	unsigned char	c, *p;
 196               		.loc 1 555 2 view .LVU50
 556:stk500boot.c  **** 	unsigned char   isLeave = 0;
 197               		.loc 1 556 2 view .LVU51
 557:stk500boot.c  **** 
 558:stk500boot.c  **** 	unsigned long	boot_timeout;
 198               		.loc 1 558 2 view .LVU52
 559:stk500boot.c  **** 	unsigned long	boot_timer;
 199               		.loc 1 559 2 view .LVU53
 560:stk500boot.c  **** 	unsigned int	boot_state;
 200               		.loc 1 560 2 view .LVU54
 561:stk500boot.c  **** #ifdef ENABLE_MONITOR
 562:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 201               		.loc 1 562 2 view .LVU55
 563:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 202               		.loc 1 563 2 view .LVU56
 564:stk500boot.c  **** #endif
 565:stk500boot.c  **** 
 566:stk500boot.c  **** 	//*	some chips dont set the stack properly
 567:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 203               		.loc 1 567 2 view .LVU57
 204               	/* #APP */
 205               	 ;  567 "stk500boot.c" 1
 206               		.set __stack, 8703
 207               	 ;  0 "" 2
 568:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 208               		.loc 1 568 2 view .LVU58
 209               	 ;  568 "stk500boot.c" 1
 210 0012 01E2      		ldi	16, 33
 211               	 ;  0 "" 2
 569:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 212               		.loc 1 569 2 view .LVU59
 213               	 ;  569 "stk500boot.c" 1
 214 0014 0EBF      		out 62,16
 215               	 ;  0 "" 2
 570:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 216               		.loc 1 570 2 view .LVU60
 217               	 ;  570 "stk500boot.c" 1
 218 0016 0FEF      		ldi	16, 255
 219               	 ;  0 "" 2
 571:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 220               		.loc 1 571 2 view .LVU61
 221               	 ;  571 "stk500boot.c" 1
 222 0018 0DBF      		out 61,16
 223               	 ;  0 "" 2
 572:stk500boot.c  **** 
 573:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 574:stk500boot.c  **** 	//************************************************************************
 575:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 576:stk500boot.c  **** 	//*	handle the watch dog timer
 577:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 224               		.loc 1 577 2 view .LVU62
 578:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 225               		.loc 1 578 2 view .LVU63
 226               		.loc 1 578 15 is_stmt 0 view .LVU64
 227               	/* #NOAPP */
 228 001a 94B7      		in r25,0x34
 229               	.LVL10:
 579:stk500boot.c  **** 
 580:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 230               		.loc 1 580 2 is_stmt 1 view .LVU65
 231               	/* #APP */
 232               	 ;  580 "stk500boot.c" 1
 233 001c F894      		cli
 234               	 ;  0 "" 2
 581:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 235               		.loc 1 581 2 view .LVU66
 236               	 ;  581 "stk500boot.c" 1
 237 001e A895      		wdr
 238               	 ;  0 "" 2
 582:stk500boot.c  **** 	MCUSR	=	0;
 239               		.loc 1 582 2 view .LVU67
 240               		.loc 1 582 8 is_stmt 0 view .LVU68
 241               	/* #NOAPP */
 242 0020 14BE      		out 0x34,__zero_reg__
 583:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 243               		.loc 1 583 2 is_stmt 1 view .LVU69
 244               		.loc 1 583 9 is_stmt 0 view .LVU70
 245 0022 8091 6000 		lds r24,96
 246 0026 8861      		ori r24,lo8(24)
 247 0028 8093 6000 		sts 96,r24
 584:stk500boot.c  **** 	WDTCSR	=	0;
 248               		.loc 1 584 2 is_stmt 1 view .LVU71
 249               		.loc 1 584 9 is_stmt 0 view .LVU72
 250 002c 1092 6000 		sts 96,__zero_reg__
 585:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 251               		.loc 1 585 2 is_stmt 1 view .LVU73
 252               	/* #APP */
 253               	 ;  585 "stk500boot.c" 1
 254 0030 7894      		sei
 255               	 ;  0 "" 2
 586:stk500boot.c  ****     
 587:stk500boot.c  ****     
 588:stk500boot.c  ****     
 589:stk500boot.c  ****        
 590:stk500boot.c  ****     
 591:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 592:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 256               		.loc 1 592 2 view .LVU74
 257               		.loc 1 592 5 is_stmt 0 view .LVU75
 258               	/* #NOAPP */
 259 0032 93FF      		sbrs r25,3
 260 0034 00C0      		rjmp .L10
 593:stk500boot.c  **** 	{
 594:stk500boot.c  **** 		app_start();
 261               		.loc 1 594 3 is_stmt 1 view .LVU76
 262 0036 E091 0000 		lds r30,app_start
 263 003a F091 0000 		lds r31,app_start+1
 264 003e 1995      		eicall
 265               	.LVL11:
 266               	.L10:
 595:stk500boot.c  **** 	}
 596:stk500boot.c  **** 	//************************************************************************
 597:stk500boot.c  **** #endif
 598:stk500boot.c  **** 
 599:stk500boot.c  **** 
 600:stk500boot.c  **** 	boot_timer	=	0;
 267               		.loc 1 600 2 view .LVU77
 601:stk500boot.c  **** 	boot_state	=	0;
 268               		.loc 1 601 2 view .LVU78
 602:stk500boot.c  **** 
 603:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 604:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 605:stk500boot.c  **** //	boot_timeout	=	170000;
 606:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 269               		.loc 1 606 2 view .LVU79
 607:stk500boot.c  **** #else
 608:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 609:stk500boot.c  **** #endif
 610:stk500boot.c  **** 	/*
 611:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 612:stk500boot.c  **** 	 */
 613:stk500boot.c  **** 
 614:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 615:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 616:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 270               		.loc 1 616 2 view .LVU80
 271               		.loc 1 616 15 is_stmt 0 view .LVU81
 272 0040 279A      		sbi 0x4,7
 617:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 618:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 273               		.loc 1 618 2 is_stmt 1 view .LVU82
 274               		.loc 1 618 15 is_stmt 0 view .LVU83
 275 0042 2F9A      		sbi 0x5,7
 619:stk500boot.c  **** 
 620:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 621:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 622:stk500boot.c  **** 	{
 623:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 624:stk500boot.c  **** 		delay_ms(100);
 625:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 626:stk500boot.c  **** 		delay_ms(100);
 627:stk500boot.c  **** 	}
 628:stk500boot.c  **** #endif
 629:stk500boot.c  **** 
 630:stk500boot.c  **** #endif
 631:stk500boot.c  **** 
 632:stk500boot.c  **** 	/*
 633:stk500boot.c  **** 	 * Init UART
 634:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 635:stk500boot.c  **** 	 */
 636:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 637:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 276               		.loc 1 637 2 is_stmt 1 view .LVU84
 277               		.loc 1 637 19 is_stmt 0 view .LVU85
 278 0044 8091 C000 		lds r24,192
 279 0048 8260      		ori r24,lo8(2)
 280 004a 8093 C000 		sts 192,r24
 638:stk500boot.c  **** #endif
 639:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 281               		.loc 1 639 2 is_stmt 1 view .LVU86
 282               		.loc 1 639 21 is_stmt 0 view .LVU87
 283 004e 80E1      		ldi r24,lo8(16)
 284 0050 8093 C400 		sts 196,r24
 640:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 285               		.loc 1 640 2 is_stmt 1 view .LVU88
 286               		.loc 1 640 19 is_stmt 0 view .LVU89
 287 0054 88E1      		ldi r24,lo8(24)
 288 0056 8093 C100 		sts 193,r24
 641:stk500boot.c  **** 
 642:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 289               		.loc 1 642 2 is_stmt 1 view .LVU90
 290               	/* #APP */
 291               	 ;  642 "stk500boot.c" 1
 292 005a 0000      		nop
 293               	 ;  0 "" 2
 643:stk500boot.c  **** 
 644:stk500boot.c  **** 
 645:stk500boot.c  **** 
 646:stk500boot.c  ****     //    sendchar('b');
 647:stk500boot.c  **** //    sendchar('o');
 648:stk500boot.c  **** //    sendchar('o');
 649:stk500boot.c  **** //    sendchar('t');
 650:stk500boot.c  **** //    sendchar('i');
 651:stk500boot.c  **** //    sendchar('n');
 652:stk500boot.c  **** //    sendchar('g');
 653:stk500boot.c  **** //    sendchar('.');
 654:stk500boot.c  **** //    sendchar('.');
 655:stk500boot.c  **** //    sendchar('.');
 656:stk500boot.c  **** //    sendchar(0x0d);
 657:stk500boot.c  **** //    sendchar(0x0a);
 658:stk500boot.c  **** //    delay_ms(100);
 659:stk500boot.c  **** 
 660:stk500boot.c  **** 	while (boot_state==0)
 294               		.loc 1 660 2 view .LVU91
 295               		.loc 1 660 8 view .LVU92
 642:stk500boot.c  **** 
 296               		.loc 1 642 2 is_stmt 0 view .LVU93
 297               	/* #NOAPP */
 298 005c 10E0      		ldi r17,0
 299 005e 00E0      		ldi r16,0
 600:stk500boot.c  **** 	boot_state	=	0;
 300               		.loc 1 600 13 view .LVU94
 301 0060 C12C      		mov r12,__zero_reg__
 302 0062 D12C      		mov r13,__zero_reg__
 303 0064 7601      		movw r14,r12
 661:stk500boot.c  **** 	{
 662:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 663:stk500boot.c  **** 		{
 664:stk500boot.c  **** 			_delay_ms(0.001);
 665:stk500boot.c  **** 			boot_timer++;
 666:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 667:stk500boot.c  **** 			{
 668:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 304               		.loc 1 668 16 view .LVU95
 305 0066 57EC      		ldi r21,lo8(-57)
 306 0068 852E      		mov r8,r21
 307 006a 5BE1      		ldi r21,lo8(27)
 308 006c 952E      		mov r9,r21
 309 006e A12C      		mov r10,__zero_reg__
 310 0070 B12C      		mov r11,__zero_reg__
 311               	.LVL12:
 312               	.L11:
 662:stk500boot.c  **** 		{
 313               		.loc 1 662 9 is_stmt 1 view .LVU96
 314               	.LBB77:
 315               	.LBI77:
 499:stk500boot.c  **** {
 316               		.loc 1 499 12 view .LVU97
 317               	.LBB78:
 501:stk500boot.c  **** }
 318               		.loc 1 501 2 view .LVU98
 501:stk500boot.c  **** }
 319               		.loc 1 501 9 is_stmt 0 view .LVU99
 320 0072 8091 C000 		lds r24,192
 321               	.LBE78:
 322               	.LBE77:
 662:stk500boot.c  **** 		{
 323               		.loc 1 662 9 view .LVU100
 324 0076 87FD      		sbrc r24,7
 325 0078 00C0      		rjmp .L14
 662:stk500boot.c  **** 		{
 326               		.loc 1 662 34 discriminator 1 view .LVU101
 327 007a 012B      		or r16,r17
 328 007c 01F4      		brne .+2
 329 007e 00C0      		rjmp .L15
 330               	.LVL13:
 331               	.L16:
 669:stk500boot.c  **** 			}
 670:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 671:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 672:stk500boot.c  **** 			{
 673:stk500boot.c  **** 				//*	toggle the LED
 674:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 675:stk500boot.c  **** 			}
 676:stk500boot.c  **** 		#endif
 677:stk500boot.c  **** 		}
 678:stk500boot.c  ****         /* PROG_PIN pulled low, indicate with LED that bootloader is active */
 679:stk500boot.c  ****         //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 680:stk500boot.c  ****         // SDCARD BOOTLOADER
 681:stk500boot.c  ****         
 682:stk500boot.c  ****         
 683:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 684:stk500boot.c  **** 		}
 685:stk500boot.c  **** 
 686:stk500boot.c  **** 
 687:stk500boot.c  **** 	if (boot_state==1)
 688:stk500boot.c  **** 	{
 689:stk500boot.c  **** 		//*	main loop
 690:stk500boot.c  **** 		while (!isLeave)
 691:stk500boot.c  **** 		{
 692:stk500boot.c  **** 			/*
 693:stk500boot.c  **** 			 * Collect received bytes to a complete message
 694:stk500boot.c  **** 			 */
 695:stk500boot.c  **** 			msgParseState	=	ST_START;
 696:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 697:stk500boot.c  **** 			{
 698:stk500boot.c  **** 				if (boot_state==1)
 699:stk500boot.c  **** 				{
 700:stk500boot.c  **** 					boot_state	=	0;
 701:stk500boot.c  **** 					c			=	UART_DATA_REG;
 702:stk500boot.c  **** 				}
 703:stk500boot.c  **** 				else
 704:stk500boot.c  **** 				{
 705:stk500boot.c  **** 				//	c	=	recchar();
 706:stk500boot.c  **** 					c	=	recchar_timeout();
 707:stk500boot.c  **** 					
 708:stk500boot.c  **** 				}
 709:stk500boot.c  **** 
 710:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 711:stk500boot.c  **** 				rcvdCharCntr++;
 712:stk500boot.c  **** 
 713:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 714:stk500boot.c  **** 				{
 715:stk500boot.c  **** 					exPointCntr++;
 716:stk500boot.c  **** 					if (exPointCntr == 3)
 717:stk500boot.c  **** 					{
 718:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 719:stk500boot.c  **** 						isLeave			=	1;
 720:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 721:stk500boot.c  **** 						break;
 722:stk500boot.c  **** 					}
 723:stk500boot.c  **** 				}
 724:stk500boot.c  **** 				else
 725:stk500boot.c  **** 				{
 726:stk500boot.c  **** 					exPointCntr	=	0;
 727:stk500boot.c  **** 				}
 728:stk500boot.c  **** 			#endif
 729:stk500boot.c  **** 
 730:stk500boot.c  **** 				switch (msgParseState)
 731:stk500boot.c  **** 				{
 732:stk500boot.c  **** 					case ST_START:
 733:stk500boot.c  **** 						if ( c == MESSAGE_START )
 734:stk500boot.c  **** 						{
 735:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 736:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 737:stk500boot.c  **** 						}
 738:stk500boot.c  **** 						break;
 739:stk500boot.c  **** 
 740:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 741:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 742:stk500boot.c  **** 						seqNum			=	c;
 743:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 744:stk500boot.c  **** 						checksum		^=	c;
 745:stk500boot.c  **** 					#else
 746:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 747:stk500boot.c  **** 						{
 748:stk500boot.c  **** 							seqNum			=	c;
 749:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 750:stk500boot.c  **** 							checksum		^=	c;
 751:stk500boot.c  **** 						}
 752:stk500boot.c  **** 						else
 753:stk500boot.c  **** 						{
 754:stk500boot.c  **** 							msgParseState	=	ST_START;
 755:stk500boot.c  **** 						}
 756:stk500boot.c  **** 					#endif
 757:stk500boot.c  **** 						break;
 758:stk500boot.c  **** 
 759:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 760:stk500boot.c  **** 						msgLength		=	c<<8;
 761:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 762:stk500boot.c  **** 						checksum		^=	c;
 763:stk500boot.c  **** 						break;
 764:stk500boot.c  **** 
 765:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 766:stk500boot.c  **** 						msgLength		|=	c;
 767:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 768:stk500boot.c  **** 						checksum		^=	c;
 769:stk500boot.c  **** 						break;
 770:stk500boot.c  **** 
 771:stk500boot.c  **** 					case ST_GET_TOKEN:
 772:stk500boot.c  **** 						if ( c == TOKEN )
 773:stk500boot.c  **** 						{
 774:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 775:stk500boot.c  **** 							checksum		^=	c;
 776:stk500boot.c  **** 							ii				=	0;
 777:stk500boot.c  **** 						}
 778:stk500boot.c  **** 						else
 779:stk500boot.c  **** 						{
 780:stk500boot.c  **** 							msgParseState	=	ST_START;
 781:stk500boot.c  **** 						}
 782:stk500boot.c  **** 						break;
 783:stk500boot.c  **** 
 784:stk500boot.c  **** 					case ST_GET_DATA:
 785:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 786:stk500boot.c  **** 						checksum		^=	c;
 787:stk500boot.c  **** 						if (ii == msgLength )
 788:stk500boot.c  **** 						{
 789:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 790:stk500boot.c  **** 						}
 791:stk500boot.c  **** 						break;
 792:stk500boot.c  **** 
 793:stk500boot.c  **** 					case ST_GET_CHECK:
 794:stk500boot.c  **** 						if ( c == checksum )
 795:stk500boot.c  **** 						{
 796:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 797:stk500boot.c  **** 						}
 798:stk500boot.c  **** 						else
 799:stk500boot.c  **** 						{
 800:stk500boot.c  **** 							msgParseState	=	ST_START;
 801:stk500boot.c  **** 						}
 802:stk500boot.c  **** 						break;
 803:stk500boot.c  **** 				}	//	switch
 804:stk500boot.c  **** 			}	//	while(msgParseState)
 805:stk500boot.c  **** 
 806:stk500boot.c  **** 			/*
 807:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 808:stk500boot.c  **** 			 */
 809:stk500boot.c  **** 
 810:stk500boot.c  **** 			switch (msgBuffer[0])
 811:stk500boot.c  **** 			{
 812:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 813:stk500boot.c  **** 				case CMD_SPI_MULTI:
 814:stk500boot.c  **** 					{
 815:stk500boot.c  **** 						unsigned char answerByte;
 816:stk500boot.c  **** 						unsigned char flag=0;
 817:stk500boot.c  **** 
 818:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 819:stk500boot.c  **** 						{
 820:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 821:stk500boot.c  **** 
 822:stk500boot.c  **** 							if ( signatureIndex == 0 )
 823:stk500boot.c  **** 							{
 824:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 825:stk500boot.c  **** 							}
 826:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 827:stk500boot.c  **** 							{
 828:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 829:stk500boot.c  **** 							}
 830:stk500boot.c  **** 							else
 831:stk500boot.c  **** 							{
 832:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 833:stk500boot.c  **** 							}
 834:stk500boot.c  **** 						}
 835:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 836:stk500boot.c  **** 						{
 837:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 838:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 839:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 840:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 841:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 842:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 843:stk500boot.c  **** 							{
 844:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 845:stk500boot.c  **** 							}
 846:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 847:stk500boot.c  **** 							{
 848:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 849:stk500boot.c  **** 							}
 850:stk500boot.c  **** 							else
 851:stk500boot.c  **** 							{
 852:stk500boot.c  **** 								answerByte	=	0;
 853:stk500boot.c  **** 							}
 854:stk500boot.c  **** 						}
 855:stk500boot.c  **** 						else
 856:stk500boot.c  **** 						{
 857:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 858:stk500boot.c  **** 						}
 859:stk500boot.c  **** 						if ( !flag )
 860:stk500boot.c  **** 						{
 861:stk500boot.c  **** 							msgLength		=	7;
 862:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 863:stk500boot.c  **** 							msgBuffer[2]	=	0;
 864:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 865:stk500boot.c  **** 							msgBuffer[4]	=	0;
 866:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 867:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 868:stk500boot.c  **** 						}
 869:stk500boot.c  **** 					}
 870:stk500boot.c  **** 					break;
 871:stk500boot.c  **** 	#endif
 872:stk500boot.c  **** 				case CMD_SIGN_ON:
 873:stk500boot.c  **** 					msgLength		=	11;
 874:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 875:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 876:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 877:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 878:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 879:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 880:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 881:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 882:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 883:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 884:stk500boot.c  **** 					break;
 885:stk500boot.c  **** 
 886:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 887:stk500boot.c  **** 					{
 888:stk500boot.c  **** 						unsigned char value;
 889:stk500boot.c  **** 
 890:stk500boot.c  **** 						switch(msgBuffer[1])
 891:stk500boot.c  **** 						{
 892:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 893:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 894:stk500boot.c  **** 							break;
 895:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 896:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 897:stk500boot.c  **** 							break;
 898:stk500boot.c  **** 						case PARAM_HW_VER:
 899:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 900:stk500boot.c  **** 							break;
 901:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 902:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 903:stk500boot.c  **** 							break;
 904:stk500boot.c  **** 						case PARAM_SW_MINOR:
 905:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 906:stk500boot.c  **** 							break;
 907:stk500boot.c  **** 						default:
 908:stk500boot.c  **** 							value	=	0;
 909:stk500boot.c  **** 							break;
 910:stk500boot.c  **** 						}
 911:stk500boot.c  **** 						msgLength		=	3;
 912:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 913:stk500boot.c  **** 						msgBuffer[2]	=	value;
 914:stk500boot.c  **** 					}
 915:stk500boot.c  **** 					break;
 916:stk500boot.c  **** 
 917:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 918:stk500boot.c  **** 					isLeave	=	1;
 919:stk500boot.c  **** 					//*	fall thru
 920:stk500boot.c  **** 
 921:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 922:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 923:stk500boot.c  **** 					msgLength		=	2;
 924:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 925:stk500boot.c  **** 					break;
 926:stk500boot.c  **** 
 927:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 928:stk500boot.c  **** 					{
 929:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 930:stk500boot.c  **** 						unsigned char signature;
 931:stk500boot.c  **** 
 932:stk500boot.c  **** 						if ( signatureIndex == 0 )
 933:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 934:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 935:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 936:stk500boot.c  **** 						else
 937:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 938:stk500boot.c  **** 
 939:stk500boot.c  **** 						msgLength		=	4;
 940:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 941:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 942:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 943:stk500boot.c  **** 					}
 944:stk500boot.c  **** 					break;
 945:stk500boot.c  **** 
 946:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 947:stk500boot.c  **** 					msgLength		=	4;
 948:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 949:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 950:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 951:stk500boot.c  **** 					break;
 952:stk500boot.c  **** 
 953:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 954:stk500boot.c  **** 					{
 955:stk500boot.c  **** 						unsigned char fuseBits;
 956:stk500boot.c  **** 
 957:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 958:stk500boot.c  **** 						{
 959:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 960:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 961:stk500boot.c  **** 							else
 962:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 963:stk500boot.c  **** 						}
 964:stk500boot.c  **** 						else
 965:stk500boot.c  **** 						{
 966:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 967:stk500boot.c  **** 						}
 968:stk500boot.c  **** 						msgLength		=	4;
 969:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 970:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 971:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 972:stk500boot.c  **** 					}
 973:stk500boot.c  **** 					break;
 974:stk500boot.c  **** 
 975:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 976:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 977:stk500boot.c  **** 					{
 978:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 979:stk500boot.c  **** 
 980:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 981:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 982:stk500boot.c  **** 						boot_spm_busy_wait();
 983:stk500boot.c  **** 
 984:stk500boot.c  **** 						msgLength		=	3;
 985:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 986:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 987:stk500boot.c  **** 					}
 988:stk500boot.c  **** 					break;
 989:stk500boot.c  **** 	#endif
 990:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 991:stk500boot.c  **** 					eraseAddress	=	0;
 992:stk500boot.c  **** 					msgLength		=	2;
 993:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 994:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 995:stk500boot.c  **** 					break;
 996:stk500boot.c  **** 
 997:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 998:stk500boot.c  **** 	#if defined(RAMPZ)
 999:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
1000:stk500boot.c  **** 	#else
1001:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
1002:stk500boot.c  **** 	#endif
1003:stk500boot.c  **** 					msgLength		=	2;
1004:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1005:stk500boot.c  **** 					break;
1006:stk500boot.c  **** 
1007:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
1008:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
1009:stk500boot.c  **** 					{
1010:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1011:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
1012:stk500boot.c  **** 						unsigned int	data;
1013:stk500boot.c  **** 						unsigned char	highByte, lowByte;
1014:stk500boot.c  ****                         address_t		tempaddress	=	address;
1015:stk500boot.c  **** 
1016:stk500boot.c  **** 
1017:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1018:stk500boot.c  **** 						{
1019:stk500boot.c  **** 							// erase only main section (bootloader protection)
1020:stk500boot.c  **** 							if (eraseAddress < APP_END )
1021:stk500boot.c  **** 							{
1022:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1023:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1024:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1025:stk500boot.c  **** 							}
1026:stk500boot.c  **** 
1027:stk500boot.c  **** 							/* Write FLASH */
1028:stk500boot.c  **** 							do {
1029:stk500boot.c  **** 								lowByte		=	*p++;
1030:stk500boot.c  **** 								highByte 	=	*p++;
1031:stk500boot.c  **** 
1032:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1033:stk500boot.c  **** 								boot_page_fill(address,data);
1034:stk500boot.c  **** 
1035:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1036:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1037:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1038:stk500boot.c  **** 
1039:stk500boot.c  **** 							boot_page_write(tempaddress);
1040:stk500boot.c  **** 							boot_spm_busy_wait();
1041:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1042:stk500boot.c  **** 						}
1043:stk500boot.c  **** 						else
1044:stk500boot.c  **** 						{
1045:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1046:stk500boot.c  **** 							uint16_t ii = address >> 1;
1047:stk500boot.c  **** 							/* write EEPROM */
1048:stk500boot.c  **** 							while (size) {
1049:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1050:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1051:stk500boot.c  **** 								ii++;
1052:stk500boot.c  **** 								size--;
1053:stk500boot.c  **** 							}
1054:stk500boot.c  **** 						}
1055:stk500boot.c  **** 						msgLength		=	2;
1056:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1057:stk500boot.c  **** 					}
1058:stk500boot.c  **** 					break;
1059:stk500boot.c  **** 
1060:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1061:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1062:stk500boot.c  **** 					{
1063:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1064:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1065:stk500boot.c  **** 						msgLength				=	size+3;
1066:stk500boot.c  **** 
1067:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1068:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1069:stk500boot.c  **** 						{
1070:stk500boot.c  **** 							unsigned int data;
1071:stk500boot.c  **** 
1072:stk500boot.c  **** 							// Read FLASH
1073:stk500boot.c  **** 							do {
1074:stk500boot.c  **** 						//#if defined(RAMPZ)
1075:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1076:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1077:stk500boot.c  **** 						#else
1078:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1079:stk500boot.c  **** 						#endif
1080:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1081:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1082:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1083:stk500boot.c  **** 								size	-=	2;
1084:stk500boot.c  **** 							}while (size);
1085:stk500boot.c  **** 						}
1086:stk500boot.c  **** 						else
1087:stk500boot.c  **** 						{
1088:stk500boot.c  **** 							/* Read EEPROM */
1089:stk500boot.c  **** 							do {
1090:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1091:stk500boot.c  **** 								EEARH	=	((address >> 8));
1092:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1093:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1094:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1095:stk500boot.c  **** 								size--;
1096:stk500boot.c  **** 							} while (size);
1097:stk500boot.c  **** 						}
1098:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1099:stk500boot.c  **** 					}
1100:stk500boot.c  **** 					break;
1101:stk500boot.c  **** 
1102:stk500boot.c  **** 				default:
1103:stk500boot.c  **** 					msgLength		=	2;
1104:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1105:stk500boot.c  **** 					break;
1106:stk500boot.c  **** 			}
1107:stk500boot.c  **** 
1108:stk500boot.c  **** 			/*
1109:stk500boot.c  **** 			 * Now send answer message back
1110:stk500boot.c  **** 			 */
1111:stk500boot.c  **** 			sendchar(MESSAGE_START);
1112:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1113:stk500boot.c  **** 
1114:stk500boot.c  **** 			sendchar(seqNum);
1115:stk500boot.c  **** 			checksum	^=	seqNum;
1116:stk500boot.c  **** 
1117:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1118:stk500boot.c  **** 			sendchar(c);
1119:stk500boot.c  **** 			checksum	^=	c;
1120:stk500boot.c  **** 
1121:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1122:stk500boot.c  **** 			sendchar(c);
1123:stk500boot.c  **** 			checksum ^= c;
1124:stk500boot.c  **** 
1125:stk500boot.c  **** 			sendchar(TOKEN);
1126:stk500boot.c  **** 			checksum ^= TOKEN;
1127:stk500boot.c  **** 
1128:stk500boot.c  **** 			p	=	msgBuffer;
1129:stk500boot.c  **** 			while ( msgLength )
1130:stk500boot.c  **** 			{
1131:stk500boot.c  **** 				c	=	*p++;
1132:stk500boot.c  **** 				sendchar(c);
1133:stk500boot.c  **** 				checksum ^=c;
1134:stk500boot.c  **** 				msgLength--;
1135:stk500boot.c  **** 			}
1136:stk500boot.c  **** 			sendchar(checksum);
1137:stk500boot.c  **** 			seqNum++;
1138:stk500boot.c  **** 	
1139:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1140:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1141:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1142:stk500boot.c  **** 		#endif
1143:stk500boot.c  **** 
1144:stk500boot.c  **** 		}
1145:stk500boot.c  **** 	}
1146:stk500boot.c  ****     
1147:stk500boot.c  ****     if(boot_state == 2){
 332               		.loc 1 1147 5 is_stmt 1 view .LVU102
1148:stk500boot.c  ****         if(eeprom_read_byte(0x63) == 0xF0){
 333               		.loc 1 1148 9 view .LVU103
 334               		.loc 1 1148 12 is_stmt 0 view .LVU104
 335 0080 83E6      		ldi r24,lo8(99)
 336 0082 90E0      		ldi r25,0
 337 0084 0E94 0000 		call eeprom_read_byte
 338               	.LVL14:
 339               		.loc 1 1148 11 view .LVU105
 340 0088 803F      		cpi r24,lo8(-16)
 341 008a 01F0      		breq .+2
 342 008c 00C0      		rjmp .L78
1149:stk500boot.c  ****            pf_mount(&Fatfs);	/* Initialize file system */
 343               		.loc 1 1149 12 is_stmt 1 view .LVU106
 344 008e 80E0      		ldi r24,lo8(Fatfs)
 345 0090 90E0      		ldi r25,hi8(Fatfs)
 346 0092 0E94 0000 		call pf_mount
 347               	.LVL15:
1150:stk500boot.c  ****            if(pf_open("firmware.bin") == FR_OK){
 348               		.loc 1 1150 12 view .LVU107
 349               		.loc 1 1150 15 is_stmt 0 view .LVU108
 350 0096 80E0      		ldi r24,lo8(.LC0)
 351 0098 90E0      		ldi r25,hi8(.LC0)
 352 009a 0E94 0000 		call pf_open
 353               	.LVL16:
 354               		.loc 1 1150 14 view .LVU109
 355 009e 8111      		cpse r24,__zero_reg__
 356 00a0 00C0      		rjmp .L78
 357               	.LBB79:
1151:stk500boot.c  ****                DWORD fa;	/* Flash address */
 358               		.loc 1 1151 16 is_stmt 1 view .LVU110
1152:stk500boot.c  ****                WORD br;	/* Bytes read */
 359               		.loc 1 1152 16 view .LVU111
1153:stk500boot.c  ****                uint8_t i = 0;
 360               		.loc 1 1153 16 view .LVU112
 361               	.LVL17:
1154:stk500boot.c  ****                sendchar(0x0d);
 362               		.loc 1 1154 16 view .LVU113
 363 00a2 8DE0      		ldi r24,lo8(13)
 364 00a4 0E94 0000 		call sendchar
 365               	.LVL18:
1155:stk500boot.c  ****                sendchar(0x0a);
 366               		.loc 1 1155 16 view .LVU114
 367 00a8 8AE0      		ldi r24,lo8(10)
 368 00aa 0E94 0000 		call sendchar
 369               	.LVL19:
1156:stk500boot.c  ****                for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) {	/* Update all application pages */
 370               		.loc 1 1156 16 view .LVU115
 371               		.loc 1 1156 29 view .LVU116
 372               		.loc 1 1156 24 is_stmt 0 view .LVU117
 373 00ae CE5D      		subi r28,lo8(-290)
 374 00b0 DE4F      		sbci r29,hi8(-290)
 375 00b2 1882      		st Y,__zero_reg__
 376 00b4 1982      		std Y+1,__zero_reg__
 377 00b6 1A82      		std Y+2,__zero_reg__
 378 00b8 1B82      		std Y+3,__zero_reg__
 379 00ba C252      		subi r28,lo8(290)
 380 00bc D140      		sbci r29,hi8(290)
 381               	.LVL20:
 382               	.L81:
1157:stk500boot.c  ****                    PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 383               		.loc 1 1157 20 is_stmt 1 view .LVU118
 384               		.loc 1 1157 33 is_stmt 0 view .LVU119
 385 00be 85B1      		in r24,0x5
 386 00c0 8058      		subi r24,lo8(-(-128))
 387 00c2 85B9      		out 0x5,r24
 388               	.LVL21:
1158:stk500boot.c  ****                    delay_ms(50);
 389               		.loc 1 1158 20 is_stmt 1 view .LVU120
 390 00c4 82E3      		ldi r24,lo8(50)
 391 00c6 90E0      		ldi r25,0
 392 00c8 0E94 0000 		call delay_ms
 393               	.LVL22:
1159:stk500boot.c  ****                    flash_erase(fa);					/* Erase a page */
 394               		.loc 1 1159 20 view .LVU121
 395 00cc CE5D      		subi r28,lo8(-290)
 396 00ce DE4F      		sbci r29,hi8(-290)
 397 00d0 6881      		ld r22,Y
 398 00d2 7981      		ldd r23,Y+1
 399 00d4 8A81      		ldd r24,Y+2
 400 00d6 9B81      		ldd r25,Y+3
 401 00d8 C252      		subi r28,lo8(290)
 402 00da D140      		sbci r29,hi8(290)
 403 00dc 0E94 0000 		call flash_erase
 404               	.LVL23:
1160:stk500boot.c  ****                    memset(Buff, 0xFF, SPM_PAGESIZE);	/* Clear buffer */
 405               		.loc 1 1160 20 view .LVU122
 406 00e0 40E0      		ldi r20,0
 407 00e2 51E0      		ldi r21,lo8(1)
 408 00e4 6FEF      		ldi r22,lo8(-1)
 409 00e6 70E0      		ldi r23,0
 410 00e8 80E0      		ldi r24,lo8(Buff)
 411 00ea 90E0      		ldi r25,hi8(Buff)
 412 00ec 0E94 0000 		call memset
 413               	.LVL24:
1161:stk500boot.c  ****                    pf_read(Buff, SPM_PAGESIZE, &br);	/* Load a page data */
 414               		.loc 1 1161 20 view .LVU123
 415 00f0 AE01      		movw r20,r28
 416 00f2 4F5F      		subi r20,-1
 417 00f4 5F4F      		sbci r21,-1
 418 00f6 60E0      		ldi r22,0
 419 00f8 71E0      		ldi r23,lo8(1)
 420 00fa 80E0      		ldi r24,lo8(Buff)
 421 00fc 90E0      		ldi r25,hi8(Buff)
 422 00fe 0E94 0000 		call pf_read
 423               	.LVL25:
1162:stk500boot.c  ****                    if(br) flash_write(fa, Buff);		/* Write it if the data is available */
 424               		.loc 1 1162 20 view .LVU124
 425               		.loc 1 1162 22 is_stmt 0 view .LVU125
 426 0102 8981      		ldd r24,Y+1
 427 0104 9A81      		ldd r25,Y+2
 428 0106 892B      		or r24,r25
 429 0108 01F0      		breq .L80
 430               		.loc 1 1162 27 is_stmt 1 discriminator 1 view .LVU126
 431 010a 40E0      		ldi r20,lo8(Buff)
 432 010c 50E0      		ldi r21,hi8(Buff)
 433 010e CE5D      		subi r28,lo8(-290)
 434 0110 DE4F      		sbci r29,hi8(-290)
 435 0112 6881      		ld r22,Y
 436 0114 7981      		ldd r23,Y+1
 437 0116 8A81      		ldd r24,Y+2
 438 0118 9B81      		ldd r25,Y+3
 439 011a C252      		subi r28,lo8(290)
 440 011c D140      		sbci r29,hi8(290)
 441 011e 0E94 0000 		call flash_write
 442               	.LVL26:
 443               	.L80:
1156:stk500boot.c  ****                    PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 444               		.loc 1 1156 43 discriminator 2 view .LVU127
1156:stk500boot.c  ****                    PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 445               		.loc 1 1156 46 is_stmt 0 discriminator 2 view .LVU128
 446 0122 CE5D      		subi r28,lo8(-290)
 447 0124 DE4F      		sbci r29,hi8(-290)
 448 0126 2881      		ld r18,Y
 449 0128 3981      		ldd r19,Y+1
 450 012a 4A81      		ldd r20,Y+2
 451 012c 5B81      		ldd r21,Y+3
 452 012e C252      		subi r28,lo8(290)
 453 0130 D140      		sbci r29,hi8(290)
 454 0132 3F5F      		subi r19,-1
 455 0134 4F4F      		sbci r20,-1
 456 0136 5F4F      		sbci r21,-1
 457 0138 CE5D      		subi r28,lo8(-290)
 458 013a DE4F      		sbci r29,hi8(-290)
 459 013c 2883      		st Y,r18
 460 013e 3983      		std Y+1,r19
 461 0140 4A83      		std Y+2,r20
 462 0142 5B83      		std Y+3,r21
 463 0144 C252      		subi r28,lo8(290)
 464 0146 D140      		sbci r29,hi8(290)
 465               	.LVL27:
1156:stk500boot.c  ****                    PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 466               		.loc 1 1156 29 is_stmt 1 discriminator 2 view .LVU129
1156:stk500boot.c  ****                    PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 467               		.loc 1 1156 16 is_stmt 0 discriminator 2 view .LVU130
 468 0148 2115      		cp r18,__zero_reg__
 469 014a 304E      		sbci r19,-32
 470 014c 4340      		sbci r20,3
 471 014e 5105      		cpc r21,__zero_reg__
 472 0150 01F0      		breq .+2
 473 0152 00C0      		rjmp .L81
1163:stk500boot.c  ****                 }
1164:stk500boot.c  ****                sendchar(0x0d);
 474               		.loc 1 1164 16 is_stmt 1 view .LVU131
 475 0154 8DE0      		ldi r24,lo8(13)
 476 0156 0E94 0000 		call sendchar
 477               	.LVL28:
1165:stk500boot.c  ****                sendchar(0x0a);
 478               		.loc 1 1165 16 view .LVU132
 479 015a 8AE0      		ldi r24,lo8(10)
 480 015c 0E94 0000 		call sendchar
 481               	.LVL29:
1166:stk500boot.c  ****                check = 0;
 482               		.loc 1 1166 16 view .LVU133
 483               		.loc 1 1166 22 is_stmt 0 view .LVU134
 484 0160 1092 0000 		sts check,__zero_reg__
1167:stk500boot.c  ****                eeprom_write_byte (0x63, 0xFF);
 485               		.loc 1 1167 16 is_stmt 1 view .LVU135
 486 0164 6FEF      		ldi r22,lo8(-1)
 487 0166 83E6      		ldi r24,lo8(99)
 488 0168 90E0      		ldi r25,0
 489 016a 0E94 0000 		call eeprom_write_byte
 490               	.LVL30:
 491 016e 00C0      		rjmp .L78
 492               	.LVL31:
 493               	.L15:
 494               		.loc 1 1167 16 is_stmt 0 view .LVU136
 495               	.LBE79:
 664:stk500boot.c  **** 			boot_timer++;
 496               		.loc 1 664 4 is_stmt 1 view .LVU137
 497               	.LBB80:
 498               	.LBI80:
 166:/usr/avr/include/util/delay.h **** {
 499               		.loc 2 166 1 view .LVU138
 500               	.LBB81:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 501               		.loc 2 168 2 view .LVU139
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 502               		.loc 2 172 2 view .LVU140
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 503               		.loc 2 173 2 view .LVU141
 174:/usr/avr/include/util/delay.h **** 
 504               		.loc 2 174 2 view .LVU142
 184:/usr/avr/include/util/delay.h **** 	#endif
 505               		.loc 2 184 3 view .LVU143
 506               		.loc 2 187 2 view .LVU144
 507 0170 25E0      		ldi r18,lo8(5)
 508 0172 2A95      	1:	dec r18
 509 0174 01F4      		brne 1b
 510 0176 0000      		nop
 511               	.LVL32:
 512               		.loc 2 187 2 is_stmt 0 view .LVU145
 513               	.LBE81:
 514               	.LBE80:
 665:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 515               		.loc 1 665 4 is_stmt 1 view .LVU146
 665:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 516               		.loc 1 665 14 is_stmt 0 view .LVU147
 517 0178 3FEF      		ldi r19,-1
 518 017a C31A      		sub r12,r19
 519 017c D30A      		sbc r13,r19
 520 017e E30A      		sbc r14,r19
 521 0180 F30A      		sbc r15,r19
 522               	.LVL33:
 666:stk500boot.c  **** 			{
 523               		.loc 1 666 4 is_stmt 1 view .LVU148
 666:stk500boot.c  **** 			{
 524               		.loc 1 666 7 is_stmt 0 view .LVU149
 525 0182 81E0      		ldi r24,lo8(1)
 526 0184 41E2      		ldi r20,33
 527 0186 C416      		cp r12,r20
 528 0188 4EE4      		ldi r20,78
 529 018a D406      		cpc r13,r20
 530 018c E104      		cpc r14,__zero_reg__
 531 018e F104      		cpc r15,__zero_reg__
 532 0190 00F4      		brsh .L12
 533 0192 80E0      		ldi r24,0
 534               	.L12:
 668:stk500boot.c  **** 			}
 535               		.loc 1 668 16 view .LVU150
 536 0194 082F      		mov r16,r24
 537               	.LVL34:
 668:stk500boot.c  **** 			}
 538               		.loc 1 668 16 view .LVU151
 539 0196 10E0      		ldi r17,0
 671:stk500boot.c  **** 			{
 540               		.loc 1 671 4 is_stmt 1 view .LVU152
 668:stk500boot.c  **** 			}
 541               		.loc 1 668 16 is_stmt 0 view .LVU153
 542 0198 C701      		movw r24,r14
 543 019a B601      		movw r22,r12
 544 019c A501      		movw r20,r10
 545 019e 9401      		movw r18,r8
 546 01a0 0E94 0000 		call __udivmodsi4
 671:stk500boot.c  **** 			{
 547               		.loc 1 671 7 view .LVU154
 548 01a4 672B      		or r22,r23
 549 01a6 682B      		or r22,r24
 550 01a8 692B      		or r22,r25
 551 01aa 01F0      		breq .+2
 552 01ac 00C0      		rjmp .L11
 674:stk500boot.c  **** 			}
 553               		.loc 1 674 5 is_stmt 1 view .LVU155
 674:stk500boot.c  **** 			}
 554               		.loc 1 674 18 is_stmt 0 view .LVU156
 555 01ae 85B1      		in r24,0x5
 556 01b0 8058      		subi r24,lo8(-(-128))
 557 01b2 85B9      		out 0x5,r24
 558 01b4 00C0      		rjmp .L11
 559               	.LVL35:
 560               	.L14:
 683:stk500boot.c  **** 		}
 561               		.loc 1 683 3 is_stmt 1 view .LVU157
 660:stk500boot.c  **** 	{
 562               		.loc 1 660 8 view .LVU158
 687:stk500boot.c  **** 	{
 563               		.loc 1 687 2 view .LVU159
 687:stk500boot.c  **** 	{
 564               		.loc 1 687 5 is_stmt 0 view .LVU160
 565 01b6 012B      		or r16,r17
 566 01b8 01F0      		breq .+2
 567 01ba 00C0      		rjmp .L16
 563:stk500boot.c  **** #endif
 568               		.loc 1 563 15 view .LVU161
 569 01bc C45D      		subi r28,lo8(-300)
 570 01be DE4F      		sbci r29,hi8(-300)
 571 01c0 1982      		std Y+1,__zero_reg__
 572 01c2 1882      		st Y,__zero_reg__
 573 01c4 CC52      		subi r28,lo8(300)
 574 01c6 D140      		sbci r29,hi8(300)
 562:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 575               		.loc 1 562 15 view .LVU162
 576 01c8 312C      		mov r3,__zero_reg__
 577 01ca 212C      		mov r2,__zero_reg__
 550:stk500boot.c  **** 	unsigned char	checksum		=	0;
 578               		.loc 1 550 15 view .LVU163
 579 01cc CE5D      		subi r28,lo8(-290)
 580 01ce DE4F      		sbci r29,hi8(-290)
 581 01d0 1982      		std Y+1,__zero_reg__
 582 01d2 1882      		st Y,__zero_reg__
 583 01d4 C252      		subi r28,lo8(290)
 584 01d6 D140      		sbci r29,hi8(290)
 548:stk500boot.c  **** 	unsigned char	msgParseState;
 585               		.loc 1 548 13 view .LVU164
 586 01d8 812C      		mov r8,__zero_reg__
 587 01da 912C      		mov r9,__zero_reg__
 588 01dc 5401      		movw r10,r8
 547:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 589               		.loc 1 547 13 view .LVU165
 590 01de 412C      		mov r4,__zero_reg__
 591 01e0 512C      		mov r5,__zero_reg__
 592 01e2 3201      		movw r6,r4
 593 01e4 41E0      		ldi r20,lo8(1)
 594 01e6 50E0      		ldi r21,0
 552:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 595               		.loc 1 552 16 view .LVU166
 596 01e8 CA5D      		subi r28,lo8(-294)
 597 01ea DE4F      		sbci r29,hi8(-294)
 598 01ec 1882      		st Y,__zero_reg__
 599 01ee C652      		subi r28,lo8(294)
 600 01f0 D140      		sbci r29,hi8(294)
 551:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 601               		.loc 1 551 16 view .LVU167
 602 01f2 D12C      		mov r13,__zero_reg__
 785:stk500boot.c  **** 						checksum		^=	c;
 603               		.loc 1 785 23 view .LVU168
 604 01f4 CE01      		movw r24,r28
 605 01f6 0196      		adiw r24,1
 606 01f8 C25E      		subi r28,lo8(-286)
 607 01fa DE4F      		sbci r29,hi8(-286)
 608 01fc 9983      		std Y+1,r25
 609 01fe 8883      		st Y,r24
 610 0200 CE51      		subi r28,lo8(286)
 611 0202 D140      		sbci r29,hi8(286)
 612 0204 C25E      		subi r28,lo8(-286)
 613 0206 DE4F      		sbci r29,hi8(-286)
 614 0208 9881      		ld r25,Y
 615 020a CE51      		subi r28,lo8(286)
 616 020c D140      		sbci r29,hi8(286)
 617 020e C25D      		subi r28,lo8(-302)
 618 0210 DE4F      		sbci r29,hi8(-302)
 619 0212 9883      		st Y,r25
 620 0214 CE52      		subi r28,lo8(302)
 621 0216 D140      		sbci r29,hi8(302)
 622 0218 C15E      		subi r28,lo8(-287)
 623 021a DE4F      		sbci r29,hi8(-287)
 624 021c A881      		ld r26,Y
 625 021e CF51      		subi r28,lo8(287)
 626 0220 D140      		sbci r29,hi8(287)
 627 0222 C15D      		subi r28,lo8(-303)
 628 0224 DE4F      		sbci r29,hi8(-303)
 629 0226 A883      		st Y,r26
 630 0228 CF52      		subi r28,lo8(303)
 631 022a D140      		sbci r29,hi8(303)
 632               	.LBB82:
1011:stk500boot.c  **** 						unsigned int	data;
 633               		.loc 1 1011 22 view .LVU169
 634 022c FE01      		movw r30,r28
 635 022e 3B96      		adiw r30,11
 636 0230 C05E      		subi r28,lo8(-288)
 637 0232 DE4F      		sbci r29,hi8(-288)
 638 0234 F983      		std Y+1,r31
 639 0236 E883      		st Y,r30
 640 0238 C052      		subi r28,lo8(288)
 641 023a D140      		sbci r29,hi8(288)
 642               	.LVL36:
 643               	.L17:
1011:stk500boot.c  **** 						unsigned int	data;
 644               		.loc 1 1011 22 view .LVU170
 645               	.LBE82:
 696:stk500boot.c  **** 			{
 646               		.loc 1 696 10 is_stmt 1 view .LVU171
 600:stk500boot.c  **** 	boot_state	=	0;
 647               		.loc 1 600 13 is_stmt 0 view .LVU172
 648 023c 30E0      		ldi r19,0
 649 023e 20E0      		ldi r18,0
 650 0240 80E0      		ldi r24,0
 651 0242 00C0      		rjmp .L84
 652               	.LVL37:
 653               	.L22:
 654               	.LBB85:
 655               	.LBB86:
 516:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 656               		.loc 1 516 3 is_stmt 1 view .LVU173
 517:stk500boot.c  **** 		{
 657               		.loc 1 517 3 view .LVU174
 517:stk500boot.c  **** 		{
 658               		.loc 1 517 6 is_stmt 0 view .LVU175
 659 0244 4150      		subi r20,1
 660 0246 5109      		sbc r21,__zero_reg__
 661 0248 6109      		sbc r22,__zero_reg__
 662 024a 7109      		sbc r23,__zero_reg__
 663               	.LVL38:
 517:stk500boot.c  **** 		{
 664               		.loc 1 517 6 view .LVU176
 665 024c 01F4      		brne .L20
 666               	.LBB87:
 519:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 667               		.loc 1 519 3 is_stmt 1 view .LVU177
 521:stk500boot.c  **** 		#else
 668               		.loc 1 521 4 view .LVU178
 669               	.LBB88:
 521:stk500boot.c  **** 		#else
 670               		.loc 1 521 11 view .LVU179
 671               	.LVL39:
 521:stk500boot.c  **** 		#else
 672               		.loc 1 521 11 view .LVU180
 521:stk500boot.c  **** 		#else
 673               		.loc 1 521 11 view .LVU181
 674               	/* #APP */
 675               	 ;  521 "stk500boot.c" 1
 676 024e 6BBF      		out 59, r22
 677 0250 FA01      		movw r30, r20
 678 0252 4791      		elpm r20, Z+
 679 0254 5691      		elpm r21, Z
 680               		
 681               	 ;  0 "" 2
 682               	.LVL40:
 521:stk500boot.c  **** 		#else
 683               		.loc 1 521 11 view .LVU182
 521:stk500boot.c  **** 		#else
 684               		.loc 1 521 11 is_stmt 0 view .LVU183
 685               	/* #NOAPP */
 686               	.LBE88:
 525:stk500boot.c  **** 			{
 687               		.loc 1 525 4 is_stmt 1 view .LVU184
 525:stk500boot.c  **** 			{
 688               		.loc 1 525 7 is_stmt 0 view .LVU185
 689 0256 4F3F      		cpi r20,-1
 690 0258 5F4F      		sbci r21,-1
 691 025a 01F0      		breq .L21
 527:stk500boot.c  **** 						"clr	r30		\n\t"
 692               		.loc 1 527 5 is_stmt 1 view .LVU186
 693               	/* #APP */
 694               	 ;  527 "stk500boot.c" 1
 695 025c EE27      		clr	r30		
 696 025e FF27      		clr	r31		
 697 0260 0994      		ijmp	
 698               		
 699               	 ;  0 "" 2
 700               	.LVL41:
 701               	/* #NOAPP */
 702               	.L21:
 527:stk500boot.c  **** 						"clr	r30		\n\t"
 703               		.loc 1 527 5 is_stmt 0 view .LVU187
 704               	.LBE87:
 705               	.LBE86:
 706               	.LBE85:
 600:stk500boot.c  **** 	boot_state	=	0;
 707               		.loc 1 600 13 view .LVU188
 708 0262 41E0      		ldi r20,lo8(1)
 709 0264 52E1      		ldi r21,lo8(18)
 710 0266 6AE7      		ldi r22,lo8(122)
 711 0268 70E0      		ldi r23,0
 712               	.L20:
 713               	.LVL42:
 714               	.LBB91:
 715               	.LBB89:
 513:stk500boot.c  **** 	{
 716               		.loc 1 513 8 is_stmt 1 view .LVU189
 513:stk500boot.c  **** 	{
 717               		.loc 1 513 11 is_stmt 0 view .LVU190
 718 026a 9091 C000 		lds r25,192
 513:stk500boot.c  **** 	{
 719               		.loc 1 513 8 view .LVU191
 720 026e 97FF      		sbrs r25,7
 721 0270 00C0      		rjmp .L22
 722 0272 00C0      		rjmp .L138
 723               	.LVL43:
 724               	.L87:
 513:stk500boot.c  **** 	{
 725               		.loc 1 513 8 view .LVU192
 726               	.LBE89:
 727               	.LBE91:
 726:stk500boot.c  **** 				}
 728               		.loc 1 726 18 view .LVU193
 729 0274 312C      		mov r3,__zero_reg__
 730 0276 212C      		mov r2,__zero_reg__
 731               	.LVL44:
 732               	.L23:
 730:stk500boot.c  **** 				{
 733               		.loc 1 730 5 is_stmt 1 view .LVU194
 734 0278 8330      		cpi r24,lo8(3)
 735 027a 01F4      		brne .+2
 736 027c 00C0      		rjmp .L25
 737 027e 00F0      		brlo .+2
 738 0280 00C0      		rjmp .L26
 739 0282 8130      		cpi r24,lo8(1)
 740 0284 01F4      		brne .+2
 741 0286 00C0      		rjmp .L27
 742 0288 8230      		cpi r24,lo8(2)
 743 028a 01F4      		brne .+2
 744 028c 00C0      		rjmp .L28
 745 028e 8823      		tst r24
 746 0290 01F4      		brne .+2
 747 0292 00C0      		rjmp .L29
 748               	.LVL45:
 749               	.L30:
 600:stk500boot.c  **** 	boot_state	=	0;
 750               		.loc 1 600 13 is_stmt 0 view .LVU195
 751 0294 40E0      		ldi r20,0
 752 0296 50E0      		ldi r21,0
 753               	.LVL46:
 754               	.L84:
 698:stk500boot.c  **** 				{
 755               		.loc 1 698 5 is_stmt 1 view .LVU196
 698:stk500boot.c  **** 				{
 756               		.loc 1 698 8 is_stmt 0 view .LVU197
 757 0298 4130      		cpi r20,1
 758 029a 5105      		cpc r21,__zero_reg__
 759 029c 01F4      		brne .L21
 760               	.LVL47:
 761               	.L138:
 762               	.LBB92:
 763               	.LBB90:
 536:stk500boot.c  **** }
 764               		.loc 1 536 2 is_stmt 1 view .LVU198
 536:stk500boot.c  **** }
 765               		.loc 1 536 9 is_stmt 0 view .LVU199
 766 029e 9091 C600 		lds r25,198
 767               	.LVL48:
 536:stk500boot.c  **** }
 768               		.loc 1 536 9 view .LVU200
 769               	.LBE90:
 770               	.LBE92:
 711:stk500boot.c  **** 
 771               		.loc 1 711 5 is_stmt 1 view .LVU201
 711:stk500boot.c  **** 
 772               		.loc 1 711 17 is_stmt 0 view .LVU202
 773 02a2 C45D      		subi r28,lo8(-300)
 774 02a4 DE4F      		sbci r29,hi8(-300)
 775 02a6 A881      		ld r26,Y
 776 02a8 B981      		ldd r27,Y+1
 777 02aa CC52      		subi r28,lo8(300)
 778 02ac D140      		sbci r29,hi8(300)
 779 02ae 1196      		adiw r26,1
 780 02b0 C45D      		subi r28,lo8(-300)
 781 02b2 DE4F      		sbci r29,hi8(-300)
 782 02b4 B983      		std Y+1,r27
 783 02b6 A883      		st Y,r26
 784 02b8 CC52      		subi r28,lo8(300)
 785 02ba D140      		sbci r29,hi8(300)
 786               	.LVL49:
 713:stk500boot.c  **** 				{
 787               		.loc 1 713 5 is_stmt 1 view .LVU203
 713:stk500boot.c  **** 				{
 788               		.loc 1 713 8 is_stmt 0 view .LVU204
 789 02bc 9132      		cpi r25,lo8(33)
 790 02be 01F4      		brne .L87
 713:stk500boot.c  **** 				{
 791               		.loc 1 713 21 discriminator 1 view .LVU205
 792 02c0 1A97      		sbiw r26,10
 793 02c2 00F4      		brsh .L87
 715:stk500boot.c  **** 					if (exPointCntr == 3)
 794               		.loc 1 715 6 is_stmt 1 view .LVU206
 715:stk500boot.c  **** 					if (exPointCntr == 3)
 795               		.loc 1 715 17 is_stmt 0 view .LVU207
 796 02c4 BFEF      		ldi r27,-1
 797 02c6 2B1A      		sub r2,r27
 798 02c8 3B0A      		sbc r3,r27
 799               	.LVL50:
 716:stk500boot.c  **** 					{
 800               		.loc 1 716 6 is_stmt 1 view .LVU208
 716:stk500boot.c  **** 					{
 801               		.loc 1 716 9 is_stmt 0 view .LVU209
 802 02ca E3E0      		ldi r30,3
 803 02cc 2E16      		cp r2,r30
 804 02ce 3104      		cpc r3,__zero_reg__
 805 02d0 01F4      		brne .L23
 718:stk500boot.c  **** 						isLeave			=	1;
 806               		.loc 1 718 20 view .LVU210
 807 02d2 312C      		mov r3,__zero_reg__
 808 02d4 212C      		mov r2,__zero_reg__
 809               	.LVL51:
 719:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 810               		.loc 1 719 17 view .LVU211
 811 02d6 71E0      		ldi r23,lo8(1)
 812 02d8 C55D      		subi r28,lo8(-299)
 813 02da DE4F      		sbci r29,hi8(-299)
 814 02dc 7883      		st Y,r23
 815 02de CB52      		subi r28,lo8(299)
 816 02e0 D140      		sbci r29,hi8(299)
 817               	.LVL52:
 818               	.L24:
 810:stk500boot.c  **** 			{
 819               		.loc 1 810 4 is_stmt 1 view .LVU212
 810:stk500boot.c  **** 			{
 820               		.loc 1 810 21 is_stmt 0 view .LVU213
 821 02e2 2981      		ldd r18,Y+1
 810:stk500boot.c  **** 			{
 822               		.loc 1 810 4 view .LVU214
 823 02e4 2431      		cpi r18,lo8(20)
 824 02e6 01F4      		brne .+2
 825 02e8 00C0      		rjmp .L37
 826 02ea 00F0      		brlo .+2
 827 02ec 00C0      		rjmp .L38
 828 02ee 2630      		cpi r18,lo8(6)
 829 02f0 01F4      		brne .+2
 830 02f2 00C0      		rjmp .L39
 831 02f4 00F0      		brlo .+2
 832 02f6 00C0      		rjmp .L40
 833 02f8 2230      		cpi r18,lo8(2)
 834 02fa 01F4      		brne .+2
 835 02fc 00C0      		rjmp .L145
 836 02fe 2330      		cpi r18,lo8(3)
 837 0300 01F4      		brne .+2
 838 0302 00C0      		rjmp .L42
 839 0304 2130      		cpi r18,lo8(1)
 840 0306 01F4      		brne .+2
 841 0308 00C0      		rjmp .L43
 842               	.L44:
1103:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 843               		.loc 1 1103 6 is_stmt 1 view .LVU215
 844               	.LVL53:
1104:stk500boot.c  **** 					break;
 845               		.loc 1 1104 6 view .LVU216
1104:stk500boot.c  **** 					break;
 846               		.loc 1 1104 19 is_stmt 0 view .LVU217
 847 030a 80EC      		ldi r24,lo8(-64)
 848 030c 8A83      		std Y+2,r24
 849 030e 00C0      		rjmp .L142
 850               	.LVL54:
 851               	.L26:
 730:stk500boot.c  **** 				{
 852               		.loc 1 730 5 view .LVU218
 853 0310 8530      		cpi r24,lo8(5)
 854 0312 01F0      		breq .L31
 855 0314 8630      		cpi r24,lo8(6)
 856 0316 01F4      		brne .+2
 857 0318 00C0      		rjmp .L32
 858 031a 8430      		cpi r24,lo8(4)
 859 031c 01F0      		breq .L33
 860               	.LVL55:
 696:stk500boot.c  **** 			{
 861               		.loc 1 696 10 is_stmt 1 view .LVU219
 862 031e 8730      		cpi r24,lo8(7)
 863 0320 01F0      		breq .+2
 864 0322 00C0      		rjmp .L30
 865               	.LVL56:
 866               	.L91:
 696:stk500boot.c  **** 			{
 867               		.loc 1 696 10 is_stmt 0 view .LVU220
 868 0324 C55D      		subi r28,lo8(-299)
 869 0326 DE4F      		sbci r29,hi8(-299)
 870 0328 1882      		st Y,__zero_reg__
 871 032a CB52      		subi r28,lo8(299)
 872 032c D140      		sbci r29,hi8(299)
 873 032e 00C0      		rjmp .L24
 874               	.LVL57:
 875               	.L29:
 733:stk500boot.c  **** 						{
 876               		.loc 1 733 7 is_stmt 1 view .LVU221
 733:stk500boot.c  **** 						{
 877               		.loc 1 733 10 is_stmt 0 view .LVU222
 878 0330 9B31      		cpi r25,lo8(27)
 879 0332 01F0      		breq .+2
 880 0334 00C0      		rjmp .L30
 736:stk500boot.c  **** 						}
 881               		.loc 1 736 18 view .LVU223
 882 0336 8BE1      		ldi r24,lo8(27)
 883 0338 D82E      		mov r13,r24
 884               	.LVL58:
 735:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 885               		.loc 1 735 22 view .LVU224
 886 033a 81E0      		ldi r24,lo8(1)
 887 033c 00C0      		rjmp .L30
 888               	.LVL59:
 889               	.L27:
 742:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 890               		.loc 1 742 7 is_stmt 1 view .LVU225
 743:stk500boot.c  **** 						checksum		^=	c;
 891               		.loc 1 743 7 view .LVU226
 744:stk500boot.c  **** 					#else
 892               		.loc 1 744 7 view .LVU227
 744:stk500boot.c  **** 					#else
 893               		.loc 1 744 17 is_stmt 0 view .LVU228
 894 033e D926      		eor r13,r25
 895               	.LVL60:
 757:stk500boot.c  **** 
 896               		.loc 1 757 7 is_stmt 1 view .LVU229
 897 0340 CA5D      		subi r28,lo8(-294)
 898 0342 DE4F      		sbci r29,hi8(-294)
 899 0344 9883      		st Y,r25
 900 0346 C652      		subi r28,lo8(294)
 901 0348 D140      		sbci r29,hi8(294)
 743:stk500boot.c  **** 						checksum		^=	c;
 902               		.loc 1 743 21 is_stmt 0 view .LVU230
 903 034a 82E0      		ldi r24,lo8(2)
 757:stk500boot.c  **** 
 904               		.loc 1 757 7 view .LVU231
 905 034c 00C0      		rjmp .L30
 906               	.LVL61:
 907               	.L28:
 760:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 908               		.loc 1 760 7 is_stmt 1 view .LVU232
 760:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 909               		.loc 1 760 21 is_stmt 0 view .LVU233
 910 034e 292F      		mov r18,r25
 911               	.LVL62:
 760:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 912               		.loc 1 760 21 view .LVU234
 913 0350 30E0      		ldi r19,0
 914 0352 322F      		mov r19,r18
 915 0354 2227      		clr r18
 916               	.LVL63:
 761:stk500boot.c  **** 						checksum		^=	c;
 917               		.loc 1 761 7 is_stmt 1 view .LVU235
 762:stk500boot.c  **** 						break;
 918               		.loc 1 762 7 view .LVU236
 762:stk500boot.c  **** 						break;
 919               		.loc 1 762 17 is_stmt 0 view .LVU237
 920 0356 D926      		eor r13,r25
 921               	.LVL64:
 763:stk500boot.c  **** 
 922               		.loc 1 763 7 is_stmt 1 view .LVU238
 761:stk500boot.c  **** 						checksum		^=	c;
 923               		.loc 1 761 21 is_stmt 0 view .LVU239
 924 0358 83E0      		ldi r24,lo8(3)
 763:stk500boot.c  **** 
 925               		.loc 1 763 7 view .LVU240
 926 035a 00C0      		rjmp .L30
 927               	.LVL65:
 928               	.L25:
 766:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 929               		.loc 1 766 7 is_stmt 1 view .LVU241
 766:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 930               		.loc 1 766 18 is_stmt 0 view .LVU242
 931 035c 292B      		or r18,r25
 932               	.LVL66:
 767:stk500boot.c  **** 						checksum		^=	c;
 933               		.loc 1 767 7 is_stmt 1 view .LVU243
 768:stk500boot.c  **** 						break;
 934               		.loc 1 768 7 view .LVU244
 768:stk500boot.c  **** 						break;
 935               		.loc 1 768 17 is_stmt 0 view .LVU245
 936 035e D926      		eor r13,r25
 937               	.LVL67:
 769:stk500boot.c  **** 
 938               		.loc 1 769 7 is_stmt 1 view .LVU246
 767:stk500boot.c  **** 						checksum		^=	c;
 939               		.loc 1 767 21 is_stmt 0 view .LVU247
 940 0360 84E0      		ldi r24,lo8(4)
 769:stk500boot.c  **** 
 941               		.loc 1 769 7 view .LVU248
 942 0362 00C0      		rjmp .L30
 943               	.LVL68:
 944               	.L33:
 772:stk500boot.c  **** 						{
 945               		.loc 1 772 7 is_stmt 1 view .LVU249
 772:stk500boot.c  **** 						{
 946               		.loc 1 772 10 is_stmt 0 view .LVU250
 947 0364 9E30      		cpi r25,lo8(14)
 948 0366 01F4      		brne .L89
 774:stk500boot.c  **** 							checksum		^=	c;
 949               		.loc 1 774 8 is_stmt 1 view .LVU251
 950               	.LVL69:
 775:stk500boot.c  **** 							ii				=	0;
 951               		.loc 1 775 8 view .LVU252
 775:stk500boot.c  **** 							ii				=	0;
 952               		.loc 1 775 18 is_stmt 0 view .LVU253
 953 0368 D926      		eor r13,r25
 954               	.LVL70:
 776:stk500boot.c  **** 						}
 955               		.loc 1 776 8 is_stmt 1 view .LVU254
 776:stk500boot.c  **** 						}
 956               		.loc 1 776 14 is_stmt 0 view .LVU255
 957 036a CE5D      		subi r28,lo8(-290)
 958 036c DE4F      		sbci r29,hi8(-290)
 959 036e 1882      		st Y,__zero_reg__
 960 0370 C252      		subi r28,lo8(290)
 961 0372 D140      		sbci r29,hi8(290)
 962 0374 CD5D      		subi r28,lo8(-291)
 963 0376 DE4F      		sbci r29,hi8(-291)
 964 0378 1882      		st Y,__zero_reg__
 965 037a C352      		subi r28,lo8(291)
 966 037c D140      		sbci r29,hi8(291)
 774:stk500boot.c  **** 							checksum		^=	c;
 967               		.loc 1 774 22 view .LVU256
 968 037e 85E0      		ldi r24,lo8(5)
 969 0380 00C0      		rjmp .L30
 970               	.LVL71:
 971               	.L31:
 785:stk500boot.c  **** 						checksum		^=	c;
 972               		.loc 1 785 7 is_stmt 1 view .LVU257
 785:stk500boot.c  **** 						checksum		^=	c;
 973               		.loc 1 785 19 is_stmt 0 view .LVU258
 974 0382 CE5D      		subi r28,lo8(-290)
 975 0384 DE4F      		sbci r29,hi8(-290)
 976 0386 4881      		ld r20,Y
 977 0388 5981      		ldd r21,Y+1
 978 038a C252      		subi r28,lo8(290)
 979 038c D140      		sbci r29,hi8(290)
 980 038e 4F5F      		subi r20,-1
 981 0390 5F4F      		sbci r21,-1
 982               	.LVL72:
 785:stk500boot.c  **** 						checksum		^=	c;
 983               		.loc 1 785 23 view .LVU259
 984 0392 E1E0      		ldi r30,lo8(1)
 985 0394 F0E0      		ldi r31,0
 986 0396 EC0F      		add r30,r28
 987 0398 FD1F      		adc r31,r29
 988 039a CE5D      		subi r28,lo8(-290)
 989 039c DE4F      		sbci r29,hi8(-290)
 990 039e 6881      		ld r22,Y
 991 03a0 7981      		ldd r23,Y+1
 992 03a2 C252      		subi r28,lo8(290)
 993 03a4 D140      		sbci r29,hi8(290)
 994 03a6 E60F      		add r30,r22
 995 03a8 F71F      		adc r31,r23
 996 03aa 9083      		st Z,r25
 786:stk500boot.c  **** 						if (ii == msgLength )
 997               		.loc 1 786 7 is_stmt 1 view .LVU260
 786:stk500boot.c  **** 						if (ii == msgLength )
 998               		.loc 1 786 17 is_stmt 0 view .LVU261
 999 03ac D926      		eor r13,r25
 1000               	.LVL73:
 787:stk500boot.c  **** 						{
 1001               		.loc 1 787 7 is_stmt 1 view .LVU262
 787:stk500boot.c  **** 						{
 1002               		.loc 1 787 10 is_stmt 0 view .LVU263
 1003 03ae 4217      		cp r20,r18
 1004 03b0 5307      		cpc r21,r19
 1005 03b2 01F0      		breq .+2
 1006 03b4 00C0      		rjmp .L90
 787:stk500boot.c  **** 						{
 1007               		.loc 1 787 10 view .LVU264
 1008 03b6 CE5D      		subi r28,lo8(-290)
 1009 03b8 DE4F      		sbci r29,hi8(-290)
 1010 03ba 3983      		std Y+1,r19
 1011 03bc 2883      		st Y,r18
 1012 03be C252      		subi r28,lo8(290)
 1013 03c0 D140      		sbci r29,hi8(290)
 789:stk500boot.c  **** 						}
 1014               		.loc 1 789 22 view .LVU265
 1015 03c2 86E0      		ldi r24,lo8(6)
 1016               	.LVL74:
 789:stk500boot.c  **** 						}
 1017               		.loc 1 789 22 view .LVU266
 1018 03c4 00C0      		rjmp .L30
 1019               	.LVL75:
 1020               	.L32:
 794:stk500boot.c  **** 						{
 1021               		.loc 1 794 7 is_stmt 1 view .LVU267
 794:stk500boot.c  **** 						{
 1022               		.loc 1 794 10 is_stmt 0 view .LVU268
 1023 03c6 9D15      		cp r25,r13
 1024 03c8 01F4      		brne .+2
 1025 03ca 00C0      		rjmp .L91
 1026               	.L89:
 780:stk500boot.c  **** 						}
 1027               		.loc 1 780 22 view .LVU269
 1028 03cc 80E0      		ldi r24,0
 1029               	.LVL76:
 780:stk500boot.c  **** 						}
 1030               		.loc 1 780 22 view .LVU270
 1031 03ce 00C0      		rjmp .L30
 1032               	.LVL77:
 1033               	.L40:
 810:stk500boot.c  **** 			{
 1034               		.loc 1 810 4 view .LVU271
 1035 03d0 2231      		cpi r18,lo8(18)
 1036 03d2 01F4      		brne .+2
 1037 03d4 00C0      		rjmp .L45
 1038 03d6 2331      		cpi r18,lo8(19)
 1039 03d8 01F0      		breq .L46
 1040 03da 2031      		cpi r18,lo8(16)
 1041 03dc 01F0      		breq .L145
 1042 03de 2131      		cpi r18,lo8(17)
 1043 03e0 01F0      		breq .+2
 1044 03e2 00C0      		rjmp .L44
 1045 03e4 F1E0      		ldi r31,lo8(1)
 1046 03e6 C55D      		subi r28,lo8(-299)
 1047 03e8 DE4F      		sbci r29,hi8(-299)
 1048 03ea F883      		st Y,r31
 1049 03ec CB52      		subi r28,lo8(299)
 1050 03ee D140      		sbci r29,hi8(299)
 1051               	.LVL78:
 923:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 1052               		.loc 1 923 6 is_stmt 1 view .LVU272
 924:stk500boot.c  **** 					break;
 1053               		.loc 1 924 6 view .LVU273
 1054               	.L145:
1003:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 1055               		.loc 1 1003 6 view .LVU274
1004:stk500boot.c  **** 					break;
 1056               		.loc 1 1004 6 view .LVU275
1004:stk500boot.c  **** 					break;
 1057               		.loc 1 1004 19 is_stmt 0 view .LVU276
 1058 03f0 1A82      		std Y+2,__zero_reg__
1005:stk500boot.c  **** 
 1059               		.loc 1 1005 6 is_stmt 1 view .LVU277
 1060               	.LVL79:
 1061               	.L142:
1105:stk500boot.c  **** 			}
 1062               		.loc 1 1105 6 view .LVU278
1103:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 1063               		.loc 1 1103 17 is_stmt 0 view .LVU279
 1064 03f2 02E0      		ldi r16,lo8(2)
 1065 03f4 10E0      		ldi r17,0
1105:stk500boot.c  **** 			}
 1066               		.loc 1 1105 6 view .LVU280
 1067 03f6 00C0      		rjmp .L56
 1068               	.LVL80:
 1069               	.L38:
 810:stk500boot.c  **** 			{
 1070               		.loc 1 810 4 view .LVU281
 1071 03f8 2931      		cpi r18,lo8(25)
 1072 03fa 01F4      		brne .+2
 1073 03fc 00C0      		rjmp .L47
 1074 03fe 00F0      		brlo .+2
 1075 0400 00C0      		rjmp .L48
 1076 0402 2631      		cpi r18,lo8(22)
 1077 0404 01F4      		brne .+2
 1078 0406 00C0      		rjmp .L37
 1079 0408 2831      		cpi r18,lo8(24)
 1080 040a 01F4      		brne .+2
 1081 040c 00C0      		rjmp .L49
 1082 040e 2531      		cpi r18,lo8(21)
 1083 0410 01F0      		breq .+2
 1084 0412 00C0      		rjmp .L44
 1085               	.L46:
 1086               	.LBB93:
1010:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 1087               		.loc 1 1010 7 is_stmt 1 view .LVU282
 1088 0414 0A81      		ldd r16,Y+2
 1089 0416 1B81      		ldd r17,Y+3
 1090 0418 1027      		eor r17,r16
 1091 041a 0127      		eor r16,r17
 1092 041c 1027      		eor r17,r16
 1093               	.LVL81:
1011:stk500boot.c  **** 						unsigned int	data;
 1094               		.loc 1 1011 7 view .LVU283
1012:stk500boot.c  **** 						unsigned char	highByte, lowByte;
 1095               		.loc 1 1012 7 view .LVU284
1013:stk500boot.c  ****                         address_t		tempaddress	=	address;
 1096               		.loc 1 1013 7 view .LVU285
1014:stk500boot.c  **** 
 1097               		.loc 1 1014 25 view .LVU286
1017:stk500boot.c  **** 						{
 1098               		.loc 1 1017 7 view .LVU287
1017:stk500boot.c  **** 						{
 1099               		.loc 1 1017 10 is_stmt 0 view .LVU288
 1100 041e 2331      		cpi r18,lo8(19)
 1101 0420 01F0      		breq .+2
 1102 0422 00C0      		rjmp .L63
1020:stk500boot.c  **** 							{
 1103               		.loc 1 1020 8 is_stmt 1 view .LVU289
1020:stk500boot.c  **** 							{
 1104               		.loc 1 1020 11 is_stmt 0 view .LVU290
 1105 0424 8114      		cp r8,__zero_reg__
 1106 0426 30EC      		ldi r19,-64
 1107 0428 9306      		cpc r9,r19
 1108 042a 33E0      		ldi r19,3
 1109 042c A306      		cpc r10,r19
 1110 042e B104      		cpc r11,__zero_reg__
 1111 0430 00F4      		brsh .L64
1022:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 1112               		.loc 1 1022 9 is_stmt 1 view .LVU291
 1113 0432 43E0      		ldi r20,lo8(3)
 1114               	/* #APP */
 1115               	 ;  1022 "stk500boot.c" 1
 1116 0434 F401      		movw r30, r8
 1117 0436 A092 5B00 		sts  91, r10
 1118 043a 4093 5700 		sts 87, r20
 1119 043e E895      		spm
 1120               		
 1121               	 ;  0 "" 2
 1122               	/* #NOAPP */
 1123               	.L65:
1023:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 1124               		.loc 1 1023 9 discriminator 1 view .LVU292
1023:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 1125               		.loc 1 1023 9 discriminator 1 view .LVU293
1023:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 1126               		.loc 1 1023 9 discriminator 1 view .LVU294
 1127 0440 07B6      		in __tmp_reg__,0x37
 1128 0442 00FC      		sbrc __tmp_reg__,0
 1129 0444 00C0      		rjmp .L65
1024:stk500boot.c  **** 							}
 1130               		.loc 1 1024 9 view .LVU295
1024:stk500boot.c  **** 							}
 1131               		.loc 1 1024 22 is_stmt 0 view .LVU296
 1132 0446 5FEF      		ldi r21,-1
 1133 0448 951A      		sub r9,r21
 1134 044a A50A      		sbc r10,r21
 1135 044c B50A      		sbc r11,r21
 1136               	.LVL82:
 1137               	.L64:
1024:stk500boot.c  **** 							}
 1138               		.loc 1 1024 22 view .LVU297
 1139 044e 8B85      		ldd r24,Y+11
 1140 0450 DE01      		movw r26,r28
 1141 0452 1196      		adiw r26,1
 1142               	.LBE93:
 1143               	.LBB94:
 937:stk500boot.c  **** 
 1144               		.loc 1 937 18 discriminator 1 view .LVU298
 1145 0454 B301      		movw r22,r6
 1146 0456 A201      		movw r20,r4
 1147               	.LBE94:
 1148               	.LBB95:
1033:stk500boot.c  **** 
 1149               		.loc 1 1033 9 discriminator 1 view .LVU299
 1150 0458 21E0      		ldi r18,lo8(1)
 1151               	.LVL83:
 1152               	.L67:
1028:stk500boot.c  **** 								lowByte		=	*p++;
 1153               		.loc 1 1028 8 is_stmt 1 discriminator 1 view .LVU300
1029:stk500boot.c  **** 								highByte 	=	*p++;
 1154               		.loc 1 1029 9 discriminator 1 view .LVU301
1030:stk500boot.c  **** 
 1155               		.loc 1 1030 9 discriminator 1 view .LVU302
1032:stk500boot.c  **** 								boot_page_fill(address,data);
 1156               		.loc 1 1032 9 discriminator 1 view .LVU303
1033:stk500boot.c  **** 
 1157               		.loc 1 1033 9 discriminator 1 view .LVU304
1032:stk500boot.c  **** 								boot_page_fill(address,data);
 1158               		.loc 1 1032 27 is_stmt 0 discriminator 1 view .LVU305
 1159 045a 1B96      		adiw r26,11
 1160 045c 9C91      		ld r25,X
 1161 045e 1B97      		sbiw r26,11
1033:stk500boot.c  **** 
 1162               		.loc 1 1033 9 discriminator 1 view .LVU306
 1163               	/* #APP */
 1164               	 ;  1033 "stk500boot.c" 1
 1165 0460 0C01      		movw  r0, r24
 1166 0462 FA01      		movw r30, r20
 1167 0464 6093 5B00 		sts 91, r22
 1168 0468 2093 5700 		sts 87, r18
 1169 046c E895      		spm
 1170 046e 1124      		clr  r1
 1171               		
 1172               	 ;  0 "" 2
1035:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 1173               		.loc 1 1035 9 is_stmt 1 discriminator 1 view .LVU307
1035:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 1174               		.loc 1 1035 17 is_stmt 0 discriminator 1 view .LVU308
 1175               	/* #NOAPP */
 1176 0470 4E5F      		subi r20,-2
 1177 0472 5F4F      		sbci r21,-1
 1178 0474 6F4F      		sbci r22,-1
 1179 0476 7F4F      		sbci r23,-1
 1180               	.LVL84:
1036:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 1181               		.loc 1 1036 9 is_stmt 1 discriminator 1 view .LVU309
1036:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 1182               		.loc 1 1036 14 is_stmt 0 discriminator 1 view .LVU310
 1183 0478 0250      		subi r16,2
 1184 047a 1109      		sbc r17,__zero_reg__
 1185               	.LVL85:
1037:stk500boot.c  **** 
 1186               		.loc 1 1037 16 is_stmt 1 discriminator 1 view .LVU311
1037:stk500boot.c  **** 
 1187               		.loc 1 1037 8 is_stmt 0 discriminator 1 view .LVU312
 1188 047c 1296      		adiw r26,2
 1189               	.LVL86:
1037:stk500boot.c  **** 
 1190               		.loc 1 1037 8 discriminator 1 view .LVU313
 1191 047e 0115      		cp r16,__zero_reg__
 1192 0480 1105      		cpc r17,__zero_reg__
 1193 0482 01F4      		brne .+2
 1194 0484 00C0      		rjmp .L66
1030:stk500boot.c  **** 
 1195               		.loc 1 1030 23 view .LVU314
 1196 0486 1A96      		adiw r26,10
 1197 0488 8C91      		ld r24,X
 1198 048a 1A97      		sbiw r26,10
 1199               	.LVL87:
1030:stk500boot.c  **** 
 1200               		.loc 1 1030 23 view .LVU315
 1201 048c 00C0      		rjmp .L67
 1202               	.LVL88:
 1203               	.L48:
1030:stk500boot.c  **** 
 1204               		.loc 1 1030 23 view .LVU316
 1205               	.LBE95:
 810:stk500boot.c  **** 			{
 1206               		.loc 1 810 4 view .LVU317
 1207 048e 2B31      		cpi r18,lo8(27)
 1208 0490 01F4      		brne .+2
 1209 0492 00C0      		rjmp .L50
 1210 0494 2D31      		cpi r18,lo8(29)
 1211 0496 01F0      		breq .L51
 1212 0498 2A31      		cpi r18,lo8(26)
 1213 049a 01F0      		breq .+2
 1214 049c 00C0      		rjmp .L44
 947:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 1215               		.loc 1 947 6 is_stmt 1 view .LVU318
 1216               	.LVL89:
 948:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1217               		.loc 1 948 6 view .LVU319
 948:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1218               		.loc 1 948 19 is_stmt 0 view .LVU320
 1219 049e 1A82      		std Y+2,__zero_reg__
 949:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 1220               		.loc 1 949 6 is_stmt 1 view .LVU321
 1221               	.LBB96:
 949:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 1222               		.loc 1 949 21 view .LVU322
 949:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 1223               		.loc 1 949 21 view .LVU323
 1224 04a0 89E0      		ldi r24,lo8(9)
 1225 04a2 E1E0      		ldi r30,lo8(1)
 1226 04a4 F0E0      		ldi r31,0
 1227               	/* #APP */
 1228               	 ;  949 "stk500boot.c" 1
 1229 04a6 8093 5700 		sts 87, r24
 1230 04aa 8491      		lpm r24, Z
 1231               		
 1232               	 ;  0 "" 2
 1233               	/* #NOAPP */
 1234               	.L143:
 1235               	.LVL90:
 949:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 1236               		.loc 1 949 21 view .LVU324
 1237               	.LBE96:
 949:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 1238               		.loc 1 949 19 is_stmt 0 view .LVU325
 1239 04ac 8B83      		std Y+3,r24
 950:stk500boot.c  **** 					break;
 1240               		.loc 1 950 6 is_stmt 1 view .LVU326
 950:stk500boot.c  **** 					break;
 1241               		.loc 1 950 19 is_stmt 0 view .LVU327
 1242 04ae 1C82      		std Y+4,__zero_reg__
 951:stk500boot.c  **** 
 1243               		.loc 1 951 6 is_stmt 1 view .LVU328
 947:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 1244               		.loc 1 947 17 is_stmt 0 view .LVU329
 1245 04b0 04E0      		ldi r16,lo8(4)
 1246 04b2 10E0      		ldi r17,0
 951:stk500boot.c  **** 
 1247               		.loc 1 951 6 view .LVU330
 1248 04b4 00C0      		rjmp .L56
 1249               	.LVL91:
 1250               	.L51:
 1251               	.LBB97:
 815:stk500boot.c  **** 						unsigned char flag=0;
 1252               		.loc 1 815 7 is_stmt 1 view .LVU331
 816:stk500boot.c  **** 
 1253               		.loc 1 816 7 view .LVU332
 818:stk500boot.c  **** 						{
 1254               		.loc 1 818 7 view .LVU333
 818:stk500boot.c  **** 						{
 1255               		.loc 1 818 21 is_stmt 0 view .LVU334
 1256 04b6 9D81      		ldd r25,Y+5
 1257               	.LVL92:
 818:stk500boot.c  **** 						{
 1258               		.loc 1 818 10 view .LVU335
 1259 04b8 9033      		cpi r25,lo8(48)
 1260 04ba 01F0      		breq .+2
 1261 04bc 00C0      		rjmp .L53
 1262               	.LBB98:
 820:stk500boot.c  **** 
 1263               		.loc 1 820 8 is_stmt 1 view .LVU336
 820:stk500boot.c  **** 
 1264               		.loc 1 820 22 is_stmt 0 view .LVU337
 1265 04be 8F81      		ldd r24,Y+7
 1266               	.LVL93:
 822:stk500boot.c  **** 							{
 1267               		.loc 1 822 8 is_stmt 1 view .LVU338
 822:stk500boot.c  **** 							{
 1268               		.loc 1 822 11 is_stmt 0 view .LVU339
 1269 04c0 8823      		tst r24
 1270 04c2 01F4      		brne .+2
 1271 04c4 00C0      		rjmp .L93
 826:stk500boot.c  **** 							{
 1272               		.loc 1 826 13 is_stmt 1 view .LVU340
 826:stk500boot.c  **** 							{
 1273               		.loc 1 826 16 is_stmt 0 view .LVU341
 1274 04c6 8130      		cpi r24,lo8(1)
 1275 04c8 01F4      		brne .+2
 1276 04ca 00C0      		rjmp .L94
 832:stk500boot.c  **** 							}
 1277               		.loc 1 832 20 view .LVU342
 1278 04cc 81E0      		ldi r24,lo8(1)
 1279               	.LVL94:
 1280               	.L54:
 832:stk500boot.c  **** 							}
 1281               		.loc 1 832 20 view .LVU343
 1282               	.LBE98:
 859:stk500boot.c  **** 						{
 1283               		.loc 1 859 7 is_stmt 1 view .LVU344
 861:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 1284               		.loc 1 861 8 view .LVU345
 862:stk500boot.c  **** 							msgBuffer[2]	=	0;
 1285               		.loc 1 862 8 view .LVU346
 862:stk500boot.c  **** 							msgBuffer[2]	=	0;
 1286               		.loc 1 862 21 is_stmt 0 view .LVU347
 1287 04ce 1A82      		std Y+2,__zero_reg__
 863:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 1288               		.loc 1 863 8 is_stmt 1 view .LVU348
 863:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 1289               		.loc 1 863 21 is_stmt 0 view .LVU349
 1290 04d0 1B82      		std Y+3,__zero_reg__
 864:stk500boot.c  **** 							msgBuffer[4]	=	0;
 1291               		.loc 1 864 8 is_stmt 1 view .LVU350
 864:stk500boot.c  **** 							msgBuffer[4]	=	0;
 1292               		.loc 1 864 21 is_stmt 0 view .LVU351
 1293 04d2 9C83      		std Y+4,r25
 865:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 1294               		.loc 1 865 8 is_stmt 1 view .LVU352
 865:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 1295               		.loc 1 865 21 is_stmt 0 view .LVU353
 1296 04d4 1D82      		std Y+5,__zero_reg__
 866:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 1297               		.loc 1 866 8 is_stmt 1 view .LVU354
 866:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 1298               		.loc 1 866 21 is_stmt 0 view .LVU355
 1299 04d6 8E83      		std Y+6,r24
 867:stk500boot.c  **** 						}
 1300               		.loc 1 867 8 is_stmt 1 view .LVU356
 867:stk500boot.c  **** 						}
 1301               		.loc 1 867 21 is_stmt 0 view .LVU357
 1302 04d8 1F82      		std Y+7,__zero_reg__
 861:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 1303               		.loc 1 861 19 view .LVU358
 1304 04da 07E0      		ldi r16,lo8(7)
 1305 04dc 10E0      		ldi r17,0
 1306               	.LVL95:
 1307               	.L56:
 861:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 1308               		.loc 1 861 19 view .LVU359
 1309               	.LBE97:
1111:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 1310               		.loc 1 1111 4 is_stmt 1 view .LVU360
 1311 04de 8BE1      		ldi r24,lo8(27)
 1312 04e0 0E94 0000 		call sendchar
 1313               	.LVL96:
1112:stk500boot.c  **** 
 1314               		.loc 1 1112 4 view .LVU361
1114:stk500boot.c  **** 			checksum	^=	seqNum;
 1315               		.loc 1 1114 4 view .LVU362
 1316 04e4 CA5D      		subi r28,lo8(-294)
 1317 04e6 DE4F      		sbci r29,hi8(-294)
 1318 04e8 8881      		ld r24,Y
 1319 04ea C652      		subi r28,lo8(294)
 1320 04ec D140      		sbci r29,hi8(294)
 1321 04ee 0E94 0000 		call sendchar
 1322               	.LVL97:
1115:stk500boot.c  **** 
 1323               		.loc 1 1115 4 view .LVU363
1117:stk500boot.c  **** 			sendchar(c);
 1324               		.loc 1 1117 4 view .LVU364
1118:stk500boot.c  **** 			checksum	^=	c;
 1325               		.loc 1 1118 4 view .LVU365
 1326 04f2 812F      		mov r24,r17
 1327 04f4 0E94 0000 		call sendchar
 1328               	.LVL98:
1119:stk500boot.c  **** 
 1329               		.loc 1 1119 4 view .LVU366
 1330 04f8 CA5D      		subi r28,lo8(-294)
 1331 04fa DE4F      		sbci r29,hi8(-294)
 1332 04fc D880      		ld r13,Y
 1333 04fe C652      		subi r28,lo8(294)
 1334 0500 D140      		sbci r29,hi8(294)
 1335 0502 D126      		eor r13,r17
 1336               	.LVL99:
1121:stk500boot.c  **** 			sendchar(c);
 1337               		.loc 1 1121 4 view .LVU367
1122:stk500boot.c  **** 			checksum ^= c;
 1338               		.loc 1 1122 4 view .LVU368
 1339 0504 802F      		mov r24,r16
 1340 0506 0E94 0000 		call sendchar
 1341               	.LVL100:
1123:stk500boot.c  **** 
 1342               		.loc 1 1123 4 view .LVU369
 1343 050a D026      		eor r13,r16
 1344               	.LVL101:
1125:stk500boot.c  **** 			checksum ^= TOKEN;
 1345               		.loc 1 1125 4 view .LVU370
 1346 050c 8EE0      		ldi r24,lo8(14)
 1347 050e 0E94 0000 		call sendchar
 1348               	.LVL102:
1126:stk500boot.c  **** 
 1349               		.loc 1 1126 4 view .LVU371
1126:stk500boot.c  **** 
 1350               		.loc 1 1126 13 is_stmt 0 view .LVU372
 1351 0512 85E1      		ldi r24,lo8(21)
 1352 0514 D826      		eor r13,r24
 1353               	.LVL103:
1128:stk500boot.c  **** 			while ( msgLength )
 1354               		.loc 1 1128 4 is_stmt 1 view .LVU373
1129:stk500boot.c  **** 			{
 1355               		.loc 1 1129 4 view .LVU374
 1356 0516 41E0      		ldi r20,lo8(1)
 1357 0518 50E0      		ldi r21,0
 1358 051a 4C0F      		add r20,r28
 1359 051c 5D1F      		adc r21,r29
 1360 051e 040F      		add r16,r20
 1361 0520 151F      		adc r17,r21
 1362               	.LVL104:
1128:stk500boot.c  **** 			while ( msgLength )
 1363               		.loc 1 1128 6 is_stmt 0 view .LVU375
 1364 0522 C25D      		subi r28,lo8(-302)
 1365 0524 DE4F      		sbci r29,hi8(-302)
 1366 0526 E880      		ld r14,Y
 1367 0528 CE52      		subi r28,lo8(302)
 1368 052a D140      		sbci r29,hi8(302)
 1369 052c C15D      		subi r28,lo8(-303)
 1370 052e DE4F      		sbci r29,hi8(-303)
 1371 0530 F880      		ld r15,Y
 1372 0532 CF52      		subi r28,lo8(303)
 1373 0534 D140      		sbci r29,hi8(303)
 1374               	.L76:
 1375               	.LVL105:
1129:stk500boot.c  **** 			{
 1376               		.loc 1 1129 10 is_stmt 1 view .LVU376
 1377 0536 0E15      		cp r16,r14
 1378 0538 1F05      		cpc r17,r15
 1379 053a 01F0      		breq .+2
 1380 053c 00C0      		rjmp .L77
1136:stk500boot.c  **** 			seqNum++;
 1381               		.loc 1 1136 4 view .LVU377
 1382 053e 8D2D      		mov r24,r13
 1383 0540 0E94 0000 		call sendchar
 1384               	.LVL106:
1137:stk500boot.c  **** 	
 1385               		.loc 1 1137 4 view .LVU378
1137:stk500boot.c  **** 	
 1386               		.loc 1 1137 10 is_stmt 0 view .LVU379
 1387 0544 CA5D      		subi r28,lo8(-294)
 1388 0546 DE4F      		sbci r29,hi8(-294)
 1389 0548 B881      		ld r27,Y
 1390 054a C652      		subi r28,lo8(294)
 1391 054c D140      		sbci r29,hi8(294)
 1392 054e BF5F      		subi r27,lo8(-(1))
 1393 0550 CA5D      		subi r28,lo8(-294)
 1394 0552 DE4F      		sbci r29,hi8(-294)
 1395 0554 B883      		st Y,r27
 1396 0556 C652      		subi r28,lo8(294)
 1397 0558 D140      		sbci r29,hi8(294)
 1398               	.LVL107:
1141:stk500boot.c  **** 		#endif
 1399               		.loc 1 1141 4 is_stmt 1 view .LVU380
1141:stk500boot.c  **** 		#endif
 1400               		.loc 1 1141 17 is_stmt 0 view .LVU381
 1401 055a 85B1      		in r24,0x5
 1402 055c 8058      		subi r24,lo8(-(-128))
 1403 055e 85B9      		out 0x5,r24
 1404               	.LVL108:
 690:stk500boot.c  **** 		{
 1405               		.loc 1 690 9 is_stmt 1 view .LVU382
 1406 0560 C55D      		subi r28,lo8(-299)
 1407 0562 DE4F      		sbci r29,hi8(-299)
 1408 0564 E881      		ld r30,Y
 1409 0566 CB52      		subi r28,lo8(299)
 1410 0568 D140      		sbci r29,hi8(299)
 1411 056a EE23      		tst r30
 1412 056c 01F4      		brne .+2
 1413 056e 00C0      		rjmp .L99
 1414               	.LVL109:
 1415               	.L78:
1168:stk500boot.c  ****            }
1169:stk500boot.c  ****         }
1170:stk500boot.c  ****     }
1171:stk500boot.c  **** 
1172:stk500boot.c  **** 
1173:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 1416               		.loc 1 1173 2 view .LVU383
 1417               	/* #APP */
 1418               	 ;  1173 "stk500boot.c" 1
 1419 0570 0000      		nop
 1420               	 ;  0 "" 2
1174:stk500boot.c  ****     
1175:stk500boot.c  **** 
1176:stk500boot.c  **** 
1177:stk500boot.c  ****           
1178:stk500boot.c  **** //    // SDCARD BOOTLOADER
1179:stk500boot.c  **** //
1180:stk500boot.c  **** //    WORD fa;	/* Flash address */
1181:stk500boot.c  **** //    WORD br;	/* Bytes read */
1182:stk500boot.c  **** //	uint8_t i = 0;
1183:stk500boot.c  **** //
1184:stk500boot.c  **** //
1185:stk500boot.c  **** //	pf_mount(&Fatfs);	/* Initialize file system */
1186:stk500boot.c  **** //
1187:stk500boot.c  **** //
1188:stk500boot.c  **** //	if (pf_open("app.bin") == FR_OK) {	/* Open application file */
1189:stk500boot.c  **** //        PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1190:stk500boot.c  **** //		
1191:stk500boot.c  **** //        for (fa = 0; fa < 0x1000; fa += SPM_PAGESIZE) {	/* Update all application pages */
1192:stk500boot.c  **** //            memset(Buff, 0xFF, SPM_PAGESIZE);		/* Clear buffer */
1193:stk500boot.c  **** //            pf_read(Buff, SPM_PAGESIZE, &br);		/* Load a page data */
1194:stk500boot.c  **** //            
1195:stk500boot.c  **** //			if (br) {					/* Bytes Read > 0? */
1196:stk500boot.c  **** //            	for (i = br; i < SPM_PAGESIZE; i++)     /* Pad the remaining last page with 0xFF so 
1197:stk500boot.c  **** //                    Buff[i] = 0xFF;
1198:stk500boot.c  **** //                if (pagecmp(fa, Buff)) {
1199:stk500boot.c  **** //                    flash_erase(fa);		/* Erase a page */
1200:stk500boot.c  **** //                    flash_write(fa, Buff);		/* Write it if the data is available */
1201:stk500boot.c  **** //                }
1202:stk500boot.c  **** //            }
1203:stk500boot.c  **** //    	}
1204:stk500boot.c  **** //        PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1205:stk500boot.c  **** //        
1206:stk500boot.c  **** //    }
1207:stk500boot.c  **** //    
1208:stk500boot.c  **** //    if (pgm_read_word(0) != 0xFFFF)		/* Start application if exist */
1209:stk500boot.c  **** //        asm volatile("jmp 0000");
1210:stk500boot.c  **** //    // SD CARD BOOTLOADER
1211:stk500boot.c  **** 
1212:stk500boot.c  ****     
1213:stk500boot.c  **** 	/*
1214:stk500boot.c  **** 	 * Now leave bootloader
1215:stk500boot.c  **** 	 */
1216:stk500boot.c  **** 
1217:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
 1421               		.loc 1 1217 2 view .LVU384
 1422               		.loc 1 1217 18 is_stmt 0 view .LVU385
 1423               	/* #NOAPP */
 1424 0572 8091 C000 		lds r24,192
 1425 0576 8D7F      		andi r24,lo8(-3)
 1426 0578 8093 C000 		sts 192,r24
1218:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 1427               		.loc 1 1218 2 is_stmt 1 view .LVU386
 1428 057c 81E1      		ldi r24,lo8(17)
 1429               	/* #APP */
 1430               	 ;  1218 "stk500boot.c" 1
 1431 057e 8093 5700 		sts 87, r24
 1432 0582 E895      		spm
 1433               		
 1434               	 ;  0 "" 2
1219:stk500boot.c  **** 
1220:stk500boot.c  **** 
1221:stk500boot.c  **** 	asm volatile(
 1435               		.loc 1 1221 2 view .LVU387
 1436               	 ;  1221 "stk500boot.c" 1
 1437 0584 EE27      		clr	r30		
 1438 0586 FF27      		clr	r31		
 1439 0588 0994      		ijmp	
 1440               		
 1441               	 ;  0 "" 2
 1442               	/* #NOAPP */
 1443               	.L82:
1222:stk500boot.c  **** 			"clr	r30		\n\t"
1223:stk500boot.c  **** 			"clr	r31		\n\t"
1224:stk500boot.c  **** 			"ijmp	\n\t"
1225:stk500boot.c  **** 			);
1226:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1227:stk500boot.c  **** //					"push r1" "\n\t"
1228:stk500boot.c  **** //					"ret"	 "\n\t"
1229:stk500boot.c  **** //					::);
1230:stk500boot.c  **** 
1231:stk500boot.c  **** 	 /*
1232:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1233:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1234:stk500boot.c  **** 	 * understand this
1235:stk500boot.c  **** 	 */
1236:stk500boot.c  **** 	for(;;);
 1444               		.loc 1 1236 2 discriminator 1 view .LVU388
 1445               		.loc 1 1236 9 discriminator 1 view .LVU389
 1446               		.loc 1 1236 7 discriminator 1 view .LVU390
 1447 058a 00C0      		rjmp .L82
 1448               	.LVL110:
 1449               	.L53:
 1450               	.LBB102:
 835:stk500boot.c  **** 						{
 1451               		.loc 1 835 12 view .LVU391
 1452 058c 892F      		mov r24,r25
 1453 058e 8075      		andi r24,lo8(80)
 835:stk500boot.c  **** 						{
 1454               		.loc 1 835 15 is_stmt 0 view .LVU392
 1455 0590 01F4      		brne .+2
 1456 0592 00C0      		rjmp .L54
 842:stk500boot.c  **** 							{
 1457               		.loc 1 842 8 is_stmt 1 view .LVU393
 1458               	.LBB99:
 844:stk500boot.c  **** 							}
 1459               		.loc 1 844 22 is_stmt 0 view .LVU394
 1460 0594 89E0      		ldi r24,lo8(9)
 1461 0596 F0E0      		ldi r31,0
 1462 0598 E0E0      		ldi r30,0
 1463               	.LBE99:
 842:stk500boot.c  **** 							{
 1464               		.loc 1 842 11 view .LVU395
 1465 059a 9035      		cpi r25,lo8(80)
 1466 059c 01F0      		breq .L139
 846:stk500boot.c  **** 							{
 1467               		.loc 1 846 13 is_stmt 1 view .LVU396
 857:stk500boot.c  **** 						}
 1468               		.loc 1 857 19 is_stmt 0 view .LVU397
 1469 059e 80E0      		ldi r24,0
 846:stk500boot.c  **** 							{
 1470               		.loc 1 846 16 view .LVU398
 1471 05a0 9835      		cpi r25,lo8(88)
 1472 05a2 01F0      		breq .+2
 1473 05a4 00C0      		rjmp .L54
 848:stk500boot.c  **** 							}
 1474               		.loc 1 848 9 is_stmt 1 view .LVU399
 1475               	.LBB100:
 848:stk500boot.c  **** 							}
 1476               		.loc 1 848 22 view .LVU400
 848:stk500boot.c  **** 							}
 1477               		.loc 1 848 22 view .LVU401
 1478 05a6 89E0      		ldi r24,lo8(9)
 1479 05a8 E3E0      		ldi r30,lo8(3)
 1480 05aa F0E0      		ldi r31,0
 1481               	.L139:
 1482               	/* #APP */
 1483               	 ;  848 "stk500boot.c" 1
 1484 05ac 8093 5700 		sts 87, r24
 1485 05b0 8491      		lpm r24, Z
 1486               		
 1487               	 ;  0 "" 2
 1488               	.LVL111:
 848:stk500boot.c  **** 							}
 1489               		.loc 1 848 22 view .LVU402
 848:stk500boot.c  **** 							}
 1490               		.loc 1 848 22 is_stmt 0 view .LVU403
 1491               	/* #NOAPP */
 1492               	.LBE100:
 1493 05b2 00C0      		rjmp .L54
 1494               	.LVL112:
 1495               	.L93:
 1496               	.LBB101:
 824:stk500boot.c  **** 							}
 1497               		.loc 1 824 20 view .LVU404
 1498 05b4 8EE1      		ldi r24,lo8(30)
 1499               	.LVL113:
 824:stk500boot.c  **** 							}
 1500               		.loc 1 824 20 view .LVU405
 1501 05b6 00C0      		rjmp .L54
 1502               	.LVL114:
 1503               	.L94:
 828:stk500boot.c  **** 							}
 1504               		.loc 1 828 20 view .LVU406
 1505 05b8 88E9      		ldi r24,lo8(-104)
 1506               	.LVL115:
 828:stk500boot.c  **** 							}
 1507               		.loc 1 828 20 view .LVU407
 1508 05ba 00C0      		rjmp .L54
 1509               	.LVL116:
 1510               	.L43:
 828:stk500boot.c  **** 							}
 1511               		.loc 1 828 20 view .LVU408
 1512               	.LBE101:
 1513               	.LBE102:
 873:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 1514               		.loc 1 873 6 is_stmt 1 view .LVU409
 874:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 1515               		.loc 1 874 6 view .LVU410
 874:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 1516               		.loc 1 874 20 is_stmt 0 view .LVU411
 1517 05bc 1A82      		std Y+2,__zero_reg__
 875:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 1518               		.loc 1 875 6 is_stmt 1 view .LVU412
 875:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 1519               		.loc 1 875 20 is_stmt 0 view .LVU413
 1520 05be 88E0      		ldi r24,lo8(8)
 1521 05c0 8B83      		std Y+3,r24
 876:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 1522               		.loc 1 876 6 is_stmt 1 view .LVU414
 876:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 1523               		.loc 1 876 20 is_stmt 0 view .LVU415
 1524 05c2 81E4      		ldi r24,lo8(65)
 1525 05c4 8C83      		std Y+4,r24
 877:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 1526               		.loc 1 877 6 is_stmt 1 view .LVU416
 877:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 1527               		.loc 1 877 20 is_stmt 0 view .LVU417
 1528 05c6 86E5      		ldi r24,lo8(86)
 1529 05c8 8D83      		std Y+5,r24
 878:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 1530               		.loc 1 878 6 is_stmt 1 view .LVU418
 878:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 1531               		.loc 1 878 20 is_stmt 0 view .LVU419
 1532 05ca 82E5      		ldi r24,lo8(82)
 1533 05cc 8E83      		std Y+6,r24
 879:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 1534               		.loc 1 879 6 is_stmt 1 view .LVU420
 879:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 1535               		.loc 1 879 20 is_stmt 0 view .LVU421
 1536 05ce 89E4      		ldi r24,lo8(73)
 1537 05d0 8F83      		std Y+7,r24
 880:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 1538               		.loc 1 880 6 is_stmt 1 view .LVU422
 880:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 1539               		.loc 1 880 20 is_stmt 0 view .LVU423
 1540 05d2 83E5      		ldi r24,lo8(83)
 1541 05d4 8887      		std Y+8,r24
 881:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 1542               		.loc 1 881 6 is_stmt 1 view .LVU424
 881:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 1543               		.loc 1 881 20 is_stmt 0 view .LVU425
 1544 05d6 80E5      		ldi r24,lo8(80)
 1545 05d8 8987      		std Y+9,r24
 882:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 1546               		.loc 1 882 6 is_stmt 1 view .LVU426
 882:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 1547               		.loc 1 882 20 is_stmt 0 view .LVU427
 1548 05da 8FE5      		ldi r24,lo8(95)
 1549 05dc 8A87      		std Y+10,r24
 883:stk500boot.c  **** 					break;
 1550               		.loc 1 883 6 is_stmt 1 view .LVU428
 883:stk500boot.c  **** 					break;
 1551               		.loc 1 883 20 is_stmt 0 view .LVU429
 1552 05de 82E3      		ldi r24,lo8(50)
 1553 05e0 8B87      		std Y+11,r24
 884:stk500boot.c  **** 
 1554               		.loc 1 884 6 is_stmt 1 view .LVU430
 873:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 1555               		.loc 1 873 17 is_stmt 0 view .LVU431
 1556 05e2 0BE0      		ldi r16,lo8(11)
 1557 05e4 10E0      		ldi r17,0
 884:stk500boot.c  **** 
 1558               		.loc 1 884 6 view .LVU432
 1559 05e6 00C0      		rjmp .L56
 1560               	.LVL117:
 1561               	.L42:
 1562               	.LBB103:
 888:stk500boot.c  **** 
 1563               		.loc 1 888 7 is_stmt 1 view .LVU433
 890:stk500boot.c  **** 						{
 1564               		.loc 1 890 7 view .LVU434
 1565 05e8 EA81      		ldd r30,Y+2
 1566 05ea E059      		subi r30,lo8(-(112))
 890:stk500boot.c  **** 						{
 1567               		.loc 1 890 23 is_stmt 0 view .LVU435
 1568 05ec 80E0      		ldi r24,0
 1569 05ee E330      		cpi r30,lo8(3)
 1570 05f0 00F4      		brsh .L57
 1571 05f2 F0E0      		ldi r31,0
 1572 05f4 E050      		subi r30,lo8(-(CSWTCH.24))
 1573 05f6 F040      		sbci r31,hi8(-(CSWTCH.24))
 1574 05f8 8081      		ld r24,Z
 1575               	.L57:
 1576               	.LVL118:
 911:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1577               		.loc 1 911 7 is_stmt 1 view .LVU436
 912:stk500boot.c  **** 						msgBuffer[2]	=	value;
 1578               		.loc 1 912 7 view .LVU437
 912:stk500boot.c  **** 						msgBuffer[2]	=	value;
 1579               		.loc 1 912 20 is_stmt 0 view .LVU438
 1580 05fa 1A82      		std Y+2,__zero_reg__
 913:stk500boot.c  **** 					}
 1581               		.loc 1 913 7 is_stmt 1 view .LVU439
 913:stk500boot.c  **** 					}
 1582               		.loc 1 913 20 is_stmt 0 view .LVU440
 1583 05fc 8B83      		std Y+3,r24
 1584               	.LBE103:
 915:stk500boot.c  **** 
 1585               		.loc 1 915 6 is_stmt 1 view .LVU441
 1586               	.LVL119:
 1587               	.L141:
 988:stk500boot.c  **** 	#endif
 1588               		.loc 1 988 6 view .LVU442
 1589               	.LBB104:
 984:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1590               		.loc 1 984 18 is_stmt 0 view .LVU443
 1591 05fe 03E0      		ldi r16,lo8(3)
 1592 0600 10E0      		ldi r17,0
 1593               	.LBE104:
 988:stk500boot.c  **** 	#endif
 1594               		.loc 1 988 6 view .LVU444
 1595 0602 00C0      		rjmp .L56
 1596               	.LVL120:
 1597               	.L50:
 1598               	.LBB106:
 929:stk500boot.c  **** 						unsigned char signature;
 1599               		.loc 1 929 7 is_stmt 1 view .LVU445
 929:stk500boot.c  **** 						unsigned char signature;
 1600               		.loc 1 929 21 is_stmt 0 view .LVU446
 1601 0604 8D81      		ldd r24,Y+5
 1602               	.LVL121:
 930:stk500boot.c  **** 
 1603               		.loc 1 930 7 is_stmt 1 view .LVU447
 932:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 1604               		.loc 1 932 7 view .LVU448
 932:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 1605               		.loc 1 932 10 is_stmt 0 view .LVU449
 1606 0606 8823      		tst r24
 1607 0608 01F0      		breq .L97
 934:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 1608               		.loc 1 934 12 is_stmt 1 view .LVU450
 934:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 1609               		.loc 1 934 15 is_stmt 0 view .LVU451
 1610 060a 8130      		cpi r24,lo8(1)
 1611 060c 01F0      		breq .L98
 937:stk500boot.c  **** 
 1612               		.loc 1 937 18 view .LVU452
 1613 060e 81E0      		ldi r24,lo8(1)
 1614               	.LVL122:
 1615               	.L144:
 937:stk500boot.c  **** 
 1616               		.loc 1 937 18 view .LVU453
 1617               	.LBE106:
 1618               	.LBB107:
 968:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1619               		.loc 1 968 7 is_stmt 1 view .LVU454
 969:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 1620               		.loc 1 969 7 view .LVU455
 969:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 1621               		.loc 1 969 20 is_stmt 0 view .LVU456
 1622 0610 1A82      		std Y+2,__zero_reg__
 970:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 1623               		.loc 1 970 7 is_stmt 1 view .LVU457
 1624 0612 00C0      		rjmp .L143
 1625               	.LVL123:
 1626               	.L97:
 970:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 1627               		.loc 1 970 7 is_stmt 0 view .LVU458
 1628               	.LBE107:
 1629               	.LBB112:
 933:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 1630               		.loc 1 933 18 view .LVU459
 1631 0614 8EE1      		ldi r24,lo8(30)
 1632               	.LVL124:
 933:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 1633               		.loc 1 933 18 view .LVU460
 1634 0616 00C0      		rjmp .L144
 1635               	.LVL125:
 1636               	.L98:
 935:stk500boot.c  **** 						else
 1637               		.loc 1 935 18 view .LVU461
 1638 0618 88E9      		ldi r24,lo8(-104)
 1639               	.LVL126:
 939:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1640               		.loc 1 939 7 is_stmt 1 view .LVU462
 940:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 1641               		.loc 1 940 7 view .LVU463
 1642 061a 00C0      		rjmp .L144
 1643               	.LVL127:
 1644               	.L49:
 940:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 1645               		.loc 1 940 7 is_stmt 0 view .LVU464
 1646               	.LBE112:
 1647               	.LBB113:
 955:stk500boot.c  **** 
 1648               		.loc 1 955 7 is_stmt 1 view .LVU465
 957:stk500boot.c  **** 						{
 1649               		.loc 1 957 7 view .LVU466
 957:stk500boot.c  **** 						{
 1650               		.loc 1 957 10 is_stmt 0 view .LVU467
 1651 061c 8B81      		ldd r24,Y+3
 1652 061e 8035      		cpi r24,lo8(80)
 1653 0620 01F4      		brne .L59
 959:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1654               		.loc 1 959 8 is_stmt 1 view .LVU468
 959:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1655               		.loc 1 959 11 is_stmt 0 view .LVU469
 1656 0622 8C81      		ldd r24,Y+4
 1657 0624 8830      		cpi r24,lo8(8)
 1658 0626 01F4      		brne .L60
 960:stk500boot.c  **** 							else
 1659               		.loc 1 960 9 is_stmt 1 view .LVU470
 1660               	.LBB108:
 960:stk500boot.c  **** 							else
 1661               		.loc 1 960 20 view .LVU471
 960:stk500boot.c  **** 							else
 1662               		.loc 1 960 20 view .LVU472
 1663 0628 89E0      		ldi r24,lo8(9)
 1664 062a E2E0      		ldi r30,lo8(2)
 1665 062c F0E0      		ldi r31,0
 1666               	.L140:
 1667               	.LBE108:
 1668               	.LBB109:
 966:stk500boot.c  **** 						}
 1669               		.loc 1 966 19 is_stmt 0 view .LVU473
 1670               	/* #APP */
 1671               	 ;  966 "stk500boot.c" 1
 1672 062e 8093 5700 		sts 87, r24
 1673 0632 8491      		lpm r24, Z
 1674               		
 1675               	 ;  0 "" 2
 1676               	.LVL128:
 966:stk500boot.c  **** 						}
 1677               		.loc 1 966 19 is_stmt 1 view .LVU474
 966:stk500boot.c  **** 						}
 1678               		.loc 1 966 19 is_stmt 0 view .LVU475
 1679               	/* #NOAPP */
 1680 0634 00C0      		rjmp .L144
 1681               	.LVL129:
 1682               	.L60:
 966:stk500boot.c  **** 						}
 1683               		.loc 1 966 19 view .LVU476
 1684               	.LBE109:
 962:stk500boot.c  **** 						}
 1685               		.loc 1 962 9 is_stmt 1 view .LVU477
 1686               	.LBB110:
 962:stk500boot.c  **** 						}
 1687               		.loc 1 962 20 view .LVU478
 962:stk500boot.c  **** 						}
 1688               		.loc 1 962 20 view .LVU479
 1689 0636 89E0      		ldi r24,lo8(9)
 1690 0638 F0E0      		ldi r31,0
 1691 063a E0E0      		ldi r30,0
 1692 063c 00C0      		rjmp .L140
 1693               	.L59:
 1694               	.LBE110:
 966:stk500boot.c  **** 						}
 1695               		.loc 1 966 8 view .LVU480
 1696               	.LBB111:
 966:stk500boot.c  **** 						}
 1697               		.loc 1 966 19 view .LVU481
 966:stk500boot.c  **** 						}
 1698               		.loc 1 966 19 view .LVU482
 1699 063e 89E0      		ldi r24,lo8(9)
 1700 0640 E3E0      		ldi r30,lo8(3)
 1701 0642 F0E0      		ldi r31,0
 1702 0644 00C0      		rjmp .L140
 1703               	.L47:
 966:stk500boot.c  **** 						}
 1704               		.loc 1 966 19 is_stmt 0 view .LVU483
 1705               	.LBE111:
 1706               	.LBE113:
 1707               	.LBB114:
 978:stk500boot.c  **** 
 1708               		.loc 1 978 7 is_stmt 1 view .LVU484
 1709               	.LVL130:
 980:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 1710               		.loc 1 980 7 view .LVU485
 981:stk500boot.c  **** 						boot_spm_busy_wait();
 1711               		.loc 1 981 7 view .LVU486
 1712               	.LBB105:
 981:stk500boot.c  **** 						boot_spm_busy_wait();
 1713               		.loc 1 981 7 view .LVU487
 981:stk500boot.c  **** 						boot_spm_busy_wait();
 1714               		.loc 1 981 7 view .LVU488
 1715 0646 8D81      		ldd r24,Y+5
 1716 0648 836C      		ori r24,lo8(-61)
 1717               	.LVL131:
 981:stk500boot.c  **** 						boot_spm_busy_wait();
 1718               		.loc 1 981 7 is_stmt 0 view .LVU489
 1719 064a 99E0      		ldi r25,lo8(9)
 1720               	.LVL132:
 981:stk500boot.c  **** 						boot_spm_busy_wait();
 1721               		.loc 1 981 7 view .LVU490
 1722               	/* #APP */
 1723               	 ;  981 "stk500boot.c" 1
 1724 064c E1E0      		ldi r30, 1
 1725 064e F0E0      		ldi r31, 0
 1726 0650 082E      		mov r0, r24
 1727 0652 9093 5700 		sts 87, r25
 1728 0656 E895      		spm
 1729               		
 1730               	 ;  0 "" 2
 1731               	/* #NOAPP */
 1732               	.L62:
 1733               	.LBE105:
 982:stk500boot.c  **** 
 1734               		.loc 1 982 7 is_stmt 1 discriminator 1 view .LVU491
 982:stk500boot.c  **** 
 1735               		.loc 1 982 7 discriminator 1 view .LVU492
 982:stk500boot.c  **** 
 1736               		.loc 1 982 7 discriminator 1 view .LVU493
 1737 0658 07B6      		in __tmp_reg__,0x37
 1738 065a 00FC      		sbrc __tmp_reg__,0
 1739 065c 00C0      		rjmp .L62
 984:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1740               		.loc 1 984 7 view .LVU494
 1741               	.LVL133:
 985:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 1742               		.loc 1 985 7 view .LVU495
 985:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 1743               		.loc 1 985 20 is_stmt 0 view .LVU496
 1744 065e 1A82      		std Y+2,__zero_reg__
 986:stk500boot.c  **** 					}
 1745               		.loc 1 986 7 is_stmt 1 view .LVU497
 986:stk500boot.c  **** 					}
 1746               		.loc 1 986 20 is_stmt 0 view .LVU498
 1747 0660 1B82      		std Y+3,__zero_reg__
 1748 0662 00C0      		rjmp .L141
 1749               	.LVL134:
 1750               	.L45:
 986:stk500boot.c  **** 					}
 1751               		.loc 1 986 20 view .LVU499
 1752               	.LBE114:
 991:stk500boot.c  **** 					msgLength		=	2;
 1753               		.loc 1 991 6 is_stmt 1 view .LVU500
 992:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 1754               		.loc 1 992 6 view .LVU501
 994:stk500boot.c  **** 					break;
 1755               		.loc 1 994 6 view .LVU502
 994:stk500boot.c  **** 					break;
 1756               		.loc 1 994 19 is_stmt 0 view .LVU503
 1757 0664 80EC      		ldi r24,lo8(-64)
 1758 0666 8A83      		std Y+2,r24
 995:stk500boot.c  **** 
 1759               		.loc 1 995 6 is_stmt 1 view .LVU504
 992:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 1760               		.loc 1 992 17 is_stmt 0 view .LVU505
 1761 0668 02E0      		ldi r16,lo8(2)
 1762 066a 10E0      		ldi r17,0
 991:stk500boot.c  **** 					msgLength		=	2;
 1763               		.loc 1 991 19 view .LVU506
 1764 066c 812C      		mov r8,__zero_reg__
 1765 066e 912C      		mov r9,__zero_reg__
 1766 0670 5401      		movw r10,r8
 995:stk500boot.c  **** 
 1767               		.loc 1 995 6 view .LVU507
 1768 0672 00C0      		rjmp .L56
 1769               	.LVL135:
 1770               	.L39:
 999:stk500boot.c  **** 	#else
 1771               		.loc 1 999 6 is_stmt 1 view .LVU508
 1772 0674 2A81      		ldd r18,Y+2
 1773 0676 3B81      		ldd r19,Y+3
 1774 0678 4C81      		ldd r20,Y+4
 1775 067a 5D81      		ldd r21,Y+5
 1776 067c C95D      		subi r28,lo8(-295)
 1777 067e DE4F      		sbci r29,hi8(-295)
 1778 0680 2883      		st Y,r18
 1779 0682 3983      		std Y+1,r19
 1780 0684 4A83      		std Y+2,r20
 1781 0686 5B83      		std Y+3,r21
 1782 0688 C752      		subi r28,lo8(295)
 1783 068a D140      		sbci r29,hi8(295)
 1784 068c CA01      		movw r24,r20
 1785 068e B901      		movw r22,r18
 1786 0690 0E94 0000 		call __bswapsi2
 999:stk500boot.c  **** 	#else
 1787               		.loc 1 999 14 is_stmt 0 view .LVU509
 1788 0694 2B01      		movw r4,r22
 1789 0696 3C01      		movw r6,r24
 1790 0698 440C      		lsl r4
 1791 069a 551C      		rol r5
 1792 069c 661C      		rol r6
 1793 069e 771C      		rol r7
 1794 06a0 00C0      		rjmp .L145
 1795               	.LVL136:
 1796               	.L66:
 1797               	.LBB115:
1039:stk500boot.c  **** 							boot_spm_busy_wait();
 1798               		.loc 1 1039 8 is_stmt 1 view .LVU510
 1799 06a2 85E0      		ldi r24,lo8(5)
 1800               	.LVL137:
1039:stk500boot.c  **** 							boot_spm_busy_wait();
 1801               		.loc 1 1039 8 is_stmt 0 view .LVU511
 1802               	/* #APP */
 1803               	 ;  1039 "stk500boot.c" 1
 1804 06a4 F201      		movw r30, r4
 1805 06a6 6092 5B00 		sts 91, r6
 1806 06aa 8093 5700 		sts 87, r24
 1807 06ae E895      		spm
 1808               		
 1809               	 ;  0 "" 2
 1810               	/* #NOAPP */
 1811               	.L68:
1040:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 1812               		.loc 1 1040 8 is_stmt 1 discriminator 1 view .LVU512
1040:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 1813               		.loc 1 1040 8 discriminator 1 view .LVU513
1040:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 1814               		.loc 1 1040 8 discriminator 1 view .LVU514
 1815 06b0 07B6      		in __tmp_reg__,0x37
 1816 06b2 00FC      		sbrc __tmp_reg__,0
 1817 06b4 00C0      		rjmp .L68
1041:stk500boot.c  **** 						}
 1818               		.loc 1 1041 8 view .LVU515
 1819 06b6 81E1      		ldi r24,lo8(17)
 1820               	/* #APP */
 1821               	 ;  1041 "stk500boot.c" 1
 1822 06b8 8093 5700 		sts 87, r24
 1823 06bc E895      		spm
 1824               		
 1825               	 ;  0 "" 2
 1826               	.LVL138:
 1827               	/* #NOAPP */
 1828               	.L69:
1055:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1829               		.loc 1 1055 7 view .LVU516
1056:stk500boot.c  **** 					}
 1830               		.loc 1 1056 7 view .LVU517
1056:stk500boot.c  **** 					}
 1831               		.loc 1 1056 20 is_stmt 0 view .LVU518
 1832 06be 1A82      		std Y+2,__zero_reg__
 1833               	.LBE115:
1058:stk500boot.c  **** 
 1834               		.loc 1 1058 6 is_stmt 1 view .LVU519
 1835 06c0 2A01      		movw r4,r20
 1836               	.LVL139:
1058:stk500boot.c  **** 
 1837               		.loc 1 1058 6 is_stmt 0 view .LVU520
 1838 06c2 3B01      		movw r6,r22
 1839 06c4 00C0      		rjmp .L142
 1840               	.LVL140:
 1841               	.L63:
 1842               	.LBB116:
 1843               	.LBB83:
1046:stk500boot.c  **** 							/* write EEPROM */
 1844               		.loc 1 1046 8 is_stmt 1 view .LVU521
1046:stk500boot.c  **** 							/* write EEPROM */
 1845               		.loc 1 1046 30 is_stmt 0 view .LVU522
 1846 06c6 D301      		movw r26,r6
 1847 06c8 C201      		movw r24,r4
 1848 06ca B695      		lsr r27
 1849 06cc A795      		ror r26
 1850 06ce 9795      		ror r25
 1851 06d0 8795      		ror r24
1046:stk500boot.c  **** 							/* write EEPROM */
 1852               		.loc 1 1046 17 view .LVU523
 1853 06d2 6C01      		movw r12,r24
 1854               	.LVL141:
1048:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 1855               		.loc 1 1048 8 is_stmt 1 view .LVU524
 1856 06d4 F801      		movw r30,r16
 1857 06d6 E80F      		add r30,r24
 1858 06d8 F91F      		adc r31,r25
 1859 06da C95D      		subi r28,lo8(-295)
 1860 06dc DE4F      		sbci r29,hi8(-295)
 1861 06de F983      		std Y+1,r31
 1862 06e0 E883      		st Y,r30
 1863 06e2 C752      		subi r28,lo8(295)
 1864 06e4 D140      		sbci r29,hi8(295)
 1865               	.LBE83:
1011:stk500boot.c  **** 						unsigned int	data;
 1866               		.loc 1 1011 22 is_stmt 0 view .LVU525
 1867 06e6 C05E      		subi r28,lo8(-288)
 1868 06e8 DE4F      		sbci r29,hi8(-288)
 1869 06ea 8881      		ld r24,Y
 1870 06ec C052      		subi r28,lo8(288)
 1871 06ee D140      		sbci r29,hi8(288)
 1872               	.LVL142:
1011:stk500boot.c  **** 						unsigned int	data;
 1873               		.loc 1 1011 22 view .LVU526
 1874 06f0 CF5D      		subi r28,lo8(-289)
 1875 06f2 DE4F      		sbci r29,hi8(-289)
 1876 06f4 9881      		ld r25,Y
 1877 06f6 C152      		subi r28,lo8(289)
 1878 06f8 D140      		sbci r29,hi8(289)
 1879               	.LVL143:
 1880               	.L70:
 1881               	.LBB84:
1048:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 1882               		.loc 1 1048 14 is_stmt 1 view .LVU527
 1883 06fa C95D      		subi r28,lo8(-295)
 1884 06fc DE4F      		sbci r29,hi8(-295)
 1885 06fe E881      		ld r30,Y
 1886 0700 F981      		ldd r31,Y+1
 1887 0702 C752      		subi r28,lo8(295)
 1888 0704 D140      		sbci r29,hi8(295)
 1889 0706 EC15      		cp r30,r12
 1890 0708 FD05      		cpc r31,r13
 1891 070a 01F4      		brne .L71
 1892 070c 30E0      		ldi r19,0
 1893 070e 20E0      		ldi r18,0
 1894 0710 000F      		lsl r16
 1895 0712 111F      		rol r17
 1896 0714 221F      		rol r18
 1897 0716 331F      		rol r19
 1898               	.LVL144:
1048:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 1899               		.loc 1 1048 14 is_stmt 0 view .LVU528
 1900 0718 B901      		movw r22,r18
 1901 071a A801      		movw r20,r16
 1902 071c 440D      		add r20,r4
 1903 071e 551D      		adc r21,r5
 1904 0720 661D      		adc r22,r6
 1905 0722 771D      		adc r23,r7
 1906 0724 00C0      		rjmp .L69
 1907               	.LVL145:
 1908               	.L71:
1049:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 1909               		.loc 1 1049 9 is_stmt 1 view .LVU529
1049:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 1910               		.loc 1 1049 9 is_stmt 0 view .LVU530
 1911 0726 DC01      		movw r26,r24
 1912 0728 6D91      		ld r22,X+
 1913               	.LVL146:
1049:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 1914               		.loc 1 1049 9 view .LVU531
 1915 072a 7D01      		movw r14,r26
 1916 072c C601      		movw r24,r12
 1917 072e 0E94 0000 		call eeprom_write_byte
 1918               	.LVL147:
1050:stk500boot.c  **** 								ii++;
 1919               		.loc 1 1050 9 is_stmt 1 view .LVU532
1051:stk500boot.c  **** 								size--;
 1920               		.loc 1 1051 9 view .LVU533
1051:stk500boot.c  **** 								size--;
 1921               		.loc 1 1051 11 is_stmt 0 view .LVU534
 1922 0732 BFEF      		ldi r27,-1
 1923 0734 CB1A      		sub r12,r27
 1924 0736 DB0A      		sbc r13,r27
 1925               	.LVL148:
1052:stk500boot.c  **** 							}
 1926               		.loc 1 1052 9 is_stmt 1 view .LVU535
1049:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 1927               		.loc 1 1049 43 is_stmt 0 view .LVU536
 1928 0738 C701      		movw r24,r14
 1929 073a 00C0      		rjmp .L70
 1930               	.LVL149:
 1931               	.L37:
1049:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 1932               		.loc 1 1049 43 view .LVU537
 1933               	.LBE84:
 1934               	.LBE116:
 1935               	.LBB117:
1063:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
 1936               		.loc 1 1063 7 is_stmt 1 view .LVU538
 1937 073c 8A81      		ldd r24,Y+2
 1938 073e 9B81      		ldd r25,Y+3
 1939 0740 9827      		eor r25,r24
 1940               	.LVL150:
1063:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
 1941               		.loc 1 1063 7 is_stmt 0 view .LVU539
 1942 0742 8927      		eor r24,r25
 1943 0744 9827      		eor r25,r24
 1944               	.LVL151:
1064:stk500boot.c  **** 						msgLength				=	size+3;
 1945               		.loc 1 1064 7 is_stmt 1 view .LVU540
1065:stk500boot.c  **** 
 1946               		.loc 1 1065 7 view .LVU541
1065:stk500boot.c  **** 
 1947               		.loc 1 1065 20 is_stmt 0 view .LVU542
 1948 0746 8C01      		movw r16,r24
 1949 0748 0D5F      		subi r16,-3
 1950 074a 1F4F      		sbci r17,-1
 1951               	.LVL152:
1067:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 1952               		.loc 1 1067 7 is_stmt 1 view .LVU543
1067:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 1953               		.loc 1 1067 12 is_stmt 0 view .LVU544
 1954 074c 1A82      		std Y+2,__zero_reg__
1068:stk500boot.c  **** 						{
 1955               		.loc 1 1068 7 is_stmt 1 view .LVU545
1068:stk500boot.c  **** 						{
 1956               		.loc 1 1068 10 is_stmt 0 view .LVU546
 1957 074e 2431      		cpi r18,lo8(20)
 1958 0750 01F4      		brne .L72
 1959               	.LVL153:
1068:stk500boot.c  **** 						{
 1960               		.loc 1 1068 10 view .LVU547
 1961 0752 DE01      		movw r26,r28
 1962 0754 1196      		adiw r26,1
 1963               	.L73:
 1964               	.LVL154:
 1965               	.LBB118:
1070:stk500boot.c  **** 
 1966               		.loc 1 1070 8 is_stmt 1 discriminator 1 view .LVU548
1073:stk500boot.c  **** 						//#if defined(RAMPZ)
 1967               		.loc 1 1073 8 discriminator 1 view .LVU549
1076:stk500boot.c  **** 						#else
 1968               		.loc 1 1076 9 discriminator 1 view .LVU550
 1969               	.LBB119:
1076:stk500boot.c  **** 						#else
 1970               		.loc 1 1076 16 discriminator 1 view .LVU551
1076:stk500boot.c  **** 						#else
 1971               		.loc 1 1076 16 discriminator 1 view .LVU552
1076:stk500boot.c  **** 						#else
 1972               		.loc 1 1076 16 discriminator 1 view .LVU553
 1973               	/* #APP */
 1974               	 ;  1076 "stk500boot.c" 1
 1975 0756 6BBE      		out 59, r6
 1976 0758 F201      		movw r30, r4
 1977 075a 2791      		elpm r18, Z+
 1978 075c 3691      		elpm r19, Z
 1979               		
 1980               	 ;  0 "" 2
 1981               	.LVL155:
1076:stk500boot.c  **** 						#else
 1982               		.loc 1 1076 16 discriminator 1 view .LVU554
1076:stk500boot.c  **** 						#else
 1983               		.loc 1 1076 16 is_stmt 0 discriminator 1 view .LVU555
 1984               	/* #NOAPP */
 1985               	.LBE119:
1080:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 1986               		.loc 1 1080 9 is_stmt 1 discriminator 1 view .LVU556
1080:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 1987               		.loc 1 1080 16 is_stmt 0 discriminator 1 view .LVU557
 1988 075e 1296      		adiw r26,2
 1989 0760 2C93      		st X,r18
 1990 0762 1297      		sbiw r26,2
1081:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 1991               		.loc 1 1081 9 is_stmt 1 discriminator 1 view .LVU558
 1992 0764 FD01      		movw r30,r26
 1993 0766 3496      		adiw r30,4
 1994               	.LVL156:
1081:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 1995               		.loc 1 1081 16 is_stmt 0 discriminator 1 view .LVU559
 1996 0768 1396      		adiw r26,3
 1997 076a 3C93      		st X,r19
 1998 076c 1397      		sbiw r26,3
1082:stk500boot.c  **** 								size	-=	2;
 1999               		.loc 1 1082 9 is_stmt 1 discriminator 1 view .LVU560
1082:stk500boot.c  **** 								size	-=	2;
 2000               		.loc 1 1082 17 is_stmt 0 discriminator 1 view .LVU561
 2001 076e 22E0      		ldi r18,2
 2002 0770 420E      		add r4,r18
 2003 0772 511C      		adc r5,__zero_reg__
 2004 0774 611C      		adc r6,__zero_reg__
 2005 0776 711C      		adc r7,__zero_reg__
 2006               	.LVL157:
1083:stk500boot.c  **** 							}while (size);
 2007               		.loc 1 1083 9 is_stmt 1 discriminator 1 view .LVU562
1083:stk500boot.c  **** 							}while (size);
 2008               		.loc 1 1083 14 is_stmt 0 discriminator 1 view .LVU563
 2009 0778 0297      		sbiw r24,2
 2010               	.LVL158:
1084:stk500boot.c  **** 						}
 2011               		.loc 1 1084 15 is_stmt 1 discriminator 1 view .LVU564
1084:stk500boot.c  **** 						}
 2012               		.loc 1 1084 8 is_stmt 0 discriminator 1 view .LVU565
 2013 077a 1296      		adiw r26,2
 2014 077c 0097      		sbiw r24,0
 2015 077e 01F4      		brne .L73
 2016               	.LVL159:
 2017               	.L74:
1084:stk500boot.c  **** 						}
 2018               		.loc 1 1084 8 discriminator 1 view .LVU566
 2019               	.LBE118:
1098:stk500boot.c  **** 					}
 2020               		.loc 1 1098 7 is_stmt 1 view .LVU567
1098:stk500boot.c  **** 					}
 2021               		.loc 1 1098 12 is_stmt 0 view .LVU568
 2022 0780 1082      		st Z,__zero_reg__
 2023               	.LBE117:
1100:stk500boot.c  **** 
 2024               		.loc 1 1100 6 is_stmt 1 view .LVU569
 2025 0782 00C0      		rjmp .L56
 2026               	.LVL160:
 2027               	.L72:
1100:stk500boot.c  **** 
 2028               		.loc 1 1100 6 is_stmt 0 view .LVU570
 2029 0784 FE01      		movw r30,r28
 2030 0786 3196      		adiw r30,1
 2031 0788 9F01      		movw r18,r30
 2032 078a 280F      		add r18,r24
 2033 078c 391F      		adc r19,r25
 2034               	.LBB120:
1068:stk500boot.c  **** 						{
 2035               		.loc 1 1068 10 view .LVU571
 2036 078e B301      		movw r22,r6
 2037 0790 A201      		movw r20,r4
 2038               	.LVL161:
 2039               	.L75:
1089:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
 2040               		.loc 1 1089 8 is_stmt 1 discriminator 1 view .LVU572
1090:stk500boot.c  **** 								EEARH	=	((address >> 8));
 2041               		.loc 1 1090 9 discriminator 1 view .LVU573
1090:stk500boot.c  **** 								EEARH	=	((address >> 8));
 2042               		.loc 1 1090 15 is_stmt 0 discriminator 1 view .LVU574
 2043 0792 41BD      		out 0x21,r20
1091:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 2044               		.loc 1 1091 9 is_stmt 1 discriminator 1 view .LVU575
1091:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 2045               		.loc 1 1091 27 is_stmt 0 discriminator 1 view .LVU576
 2046 0794 C52E      		mov r12,r21
 2047 0796 D62E      		mov r13,r22
 2048 0798 E72E      		mov r14,r23
 2049 079a FF24      		clr r15
1091:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 2050               		.loc 1 1091 15 discriminator 1 view .LVU577
 2051 079c C2BC      		out 0x22,r12
1092:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 2052               		.loc 1 1092 9 is_stmt 1 discriminator 1 view .LVU578
1092:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 2053               		.loc 1 1092 16 is_stmt 0 discriminator 1 view .LVU579
 2054 079e 4F5F      		subi r20,-1
 2055 07a0 5F4F      		sbci r21,-1
 2056 07a2 6F4F      		sbci r22,-1
 2057 07a4 7F4F      		sbci r23,-1
 2058               	.LVL162:
1093:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 2059               		.loc 1 1093 9 is_stmt 1 discriminator 1 view .LVU580
1093:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 2060               		.loc 1 1093 14 is_stmt 0 discriminator 1 view .LVU581
 2061 07a6 F89A      		sbi 0x1f,0
1094:stk500boot.c  **** 								size--;
 2062               		.loc 1 1094 9 is_stmt 1 discriminator 1 view .LVU582
 2063               	.LVL163:
1094:stk500boot.c  **** 								size--;
 2064               		.loc 1 1094 16 is_stmt 0 discriminator 1 view .LVU583
 2065 07a8 A0B5      		in r26,0x20
1094:stk500boot.c  **** 								size--;
 2066               		.loc 1 1094 14 discriminator 1 view .LVU584
 2067 07aa A283      		std Z+2,r26
1095:stk500boot.c  **** 							} while (size);
 2068               		.loc 1 1095 9 is_stmt 1 discriminator 1 view .LVU585
1096:stk500boot.c  **** 						}
 2069               		.loc 1 1096 16 discriminator 1 view .LVU586
1096:stk500boot.c  **** 						}
 2070               		.loc 1 1096 8 is_stmt 0 discriminator 1 view .LVU587
 2071 07ac 3196      		adiw r30,1
 2072               	.LVL164:
1096:stk500boot.c  **** 						}
 2073               		.loc 1 1096 8 discriminator 1 view .LVU588
 2074 07ae 2E17      		cp r18,r30
 2075 07b0 3F07      		cpc r19,r31
 2076 07b2 01F4      		brne .L75
1092:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 2077               		.loc 1 1092 16 view .LVU589
 2078 07b4 AC01      		movw r20,r24
 2079               	.LVL165:
1092:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 2080               		.loc 1 1092 16 view .LVU590
 2081 07b6 4150      		subi r20,1
 2082 07b8 5109      		sbc r21,__zero_reg__
 2083 07ba 70E0      		ldi r23,0
 2084 07bc 60E0      		ldi r22,0
 2085 07be 4F5F      		subi r20,-1
 2086 07c0 5F4F      		sbci r21,-1
 2087 07c2 6F4F      		sbci r22,-1
 2088 07c4 7F4F      		sbci r23,-1
 2089 07c6 440E      		add r4,r20
 2090 07c8 551E      		adc r5,r21
 2091 07ca 661E      		adc r6,r22
 2092 07cc 771E      		adc r7,r23
1094:stk500boot.c  **** 								size--;
 2093               		.loc 1 1094 11 view .LVU591
 2094 07ce E3E0      		ldi r30,lo8(3)
 2095 07d0 F0E0      		ldi r31,0
 2096               	.LVL166:
1094:stk500boot.c  **** 								size--;
 2097               		.loc 1 1094 11 view .LVU592
 2098 07d2 EC0F      		add r30,r28
 2099 07d4 FD1F      		adc r31,r29
 2100 07d6 E80F      		add r30,r24
 2101 07d8 F91F      		adc r31,r25
 2102 07da 00C0      		rjmp .L74
 2103               	.LVL167:
 2104               	.L77:
1094:stk500boot.c  **** 								size--;
 2105               		.loc 1 1094 11 view .LVU593
 2106               	.LBE120:
1131:stk500boot.c  **** 				sendchar(c);
 2107               		.loc 1 1131 5 is_stmt 1 view .LVU594
1131:stk500boot.c  **** 				sendchar(c);
 2108               		.loc 1 1131 7 is_stmt 0 view .LVU595
 2109 07dc D701      		movw r26,r14
 2110 07de CD90      		ld r12,X+
 2111               	.LVL168:
1131:stk500boot.c  **** 				sendchar(c);
 2112               		.loc 1 1131 7 view .LVU596
 2113 07e0 7D01      		movw r14,r26
 2114               	.LVL169:
1132:stk500boot.c  **** 				checksum ^=c;
 2115               		.loc 1 1132 5 is_stmt 1 view .LVU597
 2116 07e2 8C2D      		mov r24,r12
 2117 07e4 0E94 0000 		call sendchar
 2118               	.LVL170:
1133:stk500boot.c  **** 				msgLength--;
 2119               		.loc 1 1133 5 view .LVU598
1133:stk500boot.c  **** 				msgLength--;
 2120               		.loc 1 1133 14 is_stmt 0 view .LVU599
 2121 07e8 DC24      		eor r13,r12
 2122               	.LVL171:
1134:stk500boot.c  **** 			}
 2123               		.loc 1 1134 5 is_stmt 1 view .LVU600
 2124 07ea 00C0      		rjmp .L76
 2125               	.LVL172:
 2126               	.L99:
1134:stk500boot.c  **** 			}
 2127               		.loc 1 1134 5 is_stmt 0 view .LVU601
 2128 07ec 50E0      		ldi r21,0
 2129 07ee 40E0      		ldi r20,0
 2130 07f0 00C0      		rjmp .L17
 2131               	.LVL173:
 2132               	.L90:
1134:stk500boot.c  **** 			}
 2133               		.loc 1 1134 5 view .LVU602
 2134 07f2 CE5D      		subi r28,lo8(-290)
 2135 07f4 DE4F      		sbci r29,hi8(-290)
 2136 07f6 5983      		std Y+1,r21
 2137 07f8 4883      		st Y,r20
 2138 07fa C252      		subi r28,lo8(290)
 2139 07fc D140      		sbci r29,hi8(290)
 2140               	.LVL174:
 696:stk500boot.c  **** 			{
 2141               		.loc 1 696 10 is_stmt 1 view .LVU603
 2142 07fe 00C0      		rjmp .L30
 2143               		.cfi_endproc
 2144               	.LFE16:
 2146               		.text
 2147               	.global	PrintFromPROGMEM
 2149               	PrintFromPROGMEM:
 2150               	.LVL175:
 2151               	.LFB17:
1237:stk500boot.c  **** }
1238:stk500boot.c  **** 
1239:stk500boot.c  **** /*
1240:stk500boot.c  **** base address = f800
1241:stk500boot.c  **** 
1242:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1243:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1244:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1245:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1246:stk500boot.c  **** avrdude>
1247:stk500boot.c  **** 
1248:stk500boot.c  **** 
1249:stk500boot.c  **** base address = f000
1250:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1251:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1252:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1253:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1254:stk500boot.c  **** avrdude>
1255:stk500boot.c  **** */
1256:stk500boot.c  **** 
1257:stk500boot.c  **** //************************************************************************
1258:stk500boot.c  **** #ifdef ENABLE_MONITOR
1259:stk500boot.c  **** #include	<math.h>
1260:stk500boot.c  **** 
1261:stk500boot.c  **** unsigned long	gRamIndex;
1262:stk500boot.c  **** unsigned long	gFlashIndex;
1263:stk500boot.c  **** unsigned long	gEepromIndex;
1264:stk500boot.c  **** 
1265:stk500boot.c  **** 
1266:stk500boot.c  **** #define	true	1
1267:stk500boot.c  **** #define	false	0
1268:stk500boot.c  **** 
1269:stk500boot.c  **** #include	"avr_cpunames.h"
1270:stk500boot.c  **** 
1271:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1272:stk500boot.c  **** 	#error cpu name not defined
1273:stk500boot.c  **** #endif
1274:stk500boot.c  **** 
1275:stk500boot.c  **** #ifdef _VECTORS_SIZE
1276:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1277:stk500boot.c  **** #else
1278:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1279:stk500boot.c  **** #endif
1280:stk500boot.c  **** 
1281:stk500boot.c  **** 
1282:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1283:stk500boot.c  **** 
1284:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1285:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1286:stk500boot.c  **** #else
1287:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1288:stk500boot.c  **** #endif
1289:stk500boot.c  **** 
1290:stk500boot.c  **** 
1291:stk500boot.c  **** 
1292:stk500boot.c  **** //************************************************************************
1293:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1294:stk500boot.c  **** {
 2152               		.loc 1 1294 1 view -0
 2153               		.cfi_startproc
 2154               		.loc 1 1294 1 is_stmt 0 view .LVU605
 2155 0036 CF93      		push r28
 2156               	.LCFI2:
 2157               		.cfi_def_cfa_offset 4
 2158               		.cfi_offset 28, -3
 2159 0038 DF93      		push r29
 2160               	.LCFI3:
 2161               		.cfi_def_cfa_offset 5
 2162               		.cfi_offset 29, -4
 2163               	/* prologue: function */
 2164               	/* frame size = 0 */
 2165               	/* stack size = 2 */
 2166               	.L__stack_usage = 2
1295:stk500boot.c  **** char	theChar;
 2167               		.loc 1 1295 1 is_stmt 1 view .LVU606
1296:stk500boot.c  **** 
1297:stk500boot.c  **** 	dataPtr		+=	offset;
 2168               		.loc 1 1297 2 view .LVU607
 2169               		.loc 1 1297 11 is_stmt 0 view .LVU608
 2170 003a EC01      		movw r28,r24
 2171 003c C60F      		add r28,r22
 2172 003e D11D      		adc r29,__zero_reg__
 2173               	.LVL176:
 2174               	.L148:
1298:stk500boot.c  **** 
1299:stk500boot.c  **** 	do {
 2175               		.loc 1 1299 2 is_stmt 1 view .LVU609
1300:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1301:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 2176               		.loc 1 1301 3 view .LVU610
 2177               	.LBB121:
 2178               		.loc 1 1301 13 view .LVU611
 2179               		.loc 1 1301 13 view .LVU612
 2180               		.loc 1 1301 13 view .LVU613
 2181 0040 CE01      		movw r24,r28
 2182 0042 B0E0      		ldi r27,0
 2183 0044 A0E0      		ldi r26,0
 2184               	/* #APP */
 2185               	 ;  1301 "stk500boot.c" 1
 2186 0046 ABBF      		out 59, r26
 2187 0048 FC01      		movw r30, r24
 2188 004a 8791      		elpm r24, Z+
 2189               		
 2190               	 ;  0 "" 2
 2191               	.LVL177:
 2192               		.loc 1 1301 13 view .LVU614
 2193               		.loc 1 1301 13 is_stmt 0 view .LVU615
 2194               	/* #NOAPP */
 2195               	.LBE121:
1302:stk500boot.c  **** 	#else
1303:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1304:stk500boot.c  **** 	#endif
1305:stk500boot.c  **** 		if (theChar != 0)
 2196               		.loc 1 1305 3 is_stmt 1 view .LVU616
 2197               		.loc 1 1305 6 is_stmt 0 view .LVU617
 2198 004c 8823      		tst r24
 2199 004e 01F0      		breq .L146
 2200               	.LBB122:
1301:stk500boot.c  **** 	#else
 2201               		.loc 1 1301 13 view .LVU618
 2202 0050 2196      		adiw r28,1
 2203               	.LVL178:
1301:stk500boot.c  **** 	#else
 2204               		.loc 1 1301 13 view .LVU619
 2205               	.LBE122:
1306:stk500boot.c  **** 		{
1307:stk500boot.c  **** 			sendchar(theChar);
 2206               		.loc 1 1307 4 is_stmt 1 view .LVU620
 2207 0052 0E94 0000 		call sendchar
 2208               	.LVL179:
1308:stk500boot.c  **** 		}
1309:stk500boot.c  **** 	} while (theChar != 0);
 2209               		.loc 1 1309 10 view .LVU621
 2210 0056 00C0      		rjmp .L148
 2211               	.LVL180:
 2212               	.L146:
 2213               	/* epilogue start */
1310:stk500boot.c  **** }
 2214               		.loc 1 1310 1 is_stmt 0 view .LVU622
 2215 0058 DF91      		pop r29
 2216 005a CF91      		pop r28
 2217               	.LVL181:
 2218               		.loc 1 1310 1 view .LVU623
 2219 005c 0895      		ret
 2220               		.cfi_endproc
 2221               	.LFE17:
 2223               	.global	PrintNewLine
 2225               	PrintNewLine:
 2226               	.LFB18:
1311:stk500boot.c  **** 
1312:stk500boot.c  **** //************************************************************************
1313:stk500boot.c  **** void	PrintNewLine(void)
1314:stk500boot.c  **** {
 2227               		.loc 1 1314 1 is_stmt 1 view -0
 2228               		.cfi_startproc
 2229               	/* prologue: function */
 2230               	/* frame size = 0 */
 2231               	/* stack size = 0 */
 2232               	.L__stack_usage = 0
1315:stk500boot.c  **** 	sendchar(0x0d);
 2233               		.loc 1 1315 2 view .LVU625
 2234 005e 8DE0      		ldi r24,lo8(13)
 2235 0060 0E94 0000 		call sendchar
 2236               	.LVL182:
1316:stk500boot.c  **** 	sendchar(0x0a);
 2237               		.loc 1 1316 2 view .LVU626
 2238 0064 8AE0      		ldi r24,lo8(10)
 2239 0066 0C94 0000 		jmp sendchar
 2240               	.LVL183:
 2241               		.cfi_endproc
 2242               	.LFE18:
 2244               	.global	PrintFromPROGMEMln
 2246               	PrintFromPROGMEMln:
 2247               	.LVL184:
 2248               	.LFB19:
1317:stk500boot.c  **** }
1318:stk500boot.c  **** 
1319:stk500boot.c  **** 
1320:stk500boot.c  **** //************************************************************************
1321:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1322:stk500boot.c  **** {
 2249               		.loc 1 1322 1 view -0
 2250               		.cfi_startproc
 2251               	/* prologue: function */
 2252               	/* frame size = 0 */
 2253               	/* stack size = 0 */
 2254               	.L__stack_usage = 0
1323:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 2255               		.loc 1 1323 2 view .LVU628
 2256 006a 0E94 0000 		call PrintFromPROGMEM
 2257               	.LVL185:
1324:stk500boot.c  **** 
1325:stk500boot.c  **** 	PrintNewLine();
 2258               		.loc 1 1325 2 view .LVU629
 2259 006e 0C94 0000 		jmp PrintNewLine
 2260               	.LVL186:
 2261               		.cfi_endproc
 2262               	.LFE19:
 2264               	.global	PrintString
 2266               	PrintString:
 2267               	.LVL187:
 2268               	.LFB20:
1326:stk500boot.c  **** }
1327:stk500boot.c  **** 
1328:stk500boot.c  **** 
1329:stk500boot.c  **** //************************************************************************
1330:stk500boot.c  **** void	PrintString(char *textString)
1331:stk500boot.c  **** {
 2269               		.loc 1 1331 1 view -0
 2270               		.cfi_startproc
 2271               		.loc 1 1331 1 is_stmt 0 view .LVU631
 2272 0072 CF93      		push r28
 2273               	.LCFI4:
 2274               		.cfi_def_cfa_offset 4
 2275               		.cfi_offset 28, -3
 2276 0074 DF93      		push r29
 2277               	.LCFI5:
 2278               		.cfi_def_cfa_offset 5
 2279               		.cfi_offset 29, -4
 2280               	/* prologue: function */
 2281               	/* frame size = 0 */
 2282               	/* stack size = 2 */
 2283               	.L__stack_usage = 2
 2284 0076 EC01      		movw r28,r24
1332:stk500boot.c  **** char	theChar;
 2285               		.loc 1 1332 1 is_stmt 1 view .LVU632
1333:stk500boot.c  **** int		ii;
 2286               		.loc 1 1333 1 view .LVU633
1334:stk500boot.c  **** 
1335:stk500boot.c  **** 	theChar		=	1;
 2287               		.loc 1 1335 2 view .LVU634
 2288               	.LVL188:
1336:stk500boot.c  **** 	ii			=	0;
 2289               		.loc 1 1336 2 view .LVU635
1337:stk500boot.c  **** 	while (theChar != 0)
 2290               		.loc 1 1337 2 view .LVU636
 2291               		.loc 1 1337 8 view .LVU637
 2292               	.L153:
1338:stk500boot.c  **** 	{
1339:stk500boot.c  **** 		theChar	=	textString[ii];
 2293               		.loc 1 1339 3 view .LVU638
 2294               		.loc 1 1339 11 is_stmt 0 view .LVU639
 2295 0078 8991      		ld r24,Y+
 2296               	.LVL189:
1340:stk500boot.c  **** 		if (theChar != 0)
 2297               		.loc 1 1340 3 is_stmt 1 view .LVU640
 2298               		.loc 1 1340 6 is_stmt 0 view .LVU641
 2299 007a 8823      		tst r24
 2300 007c 01F0      		breq .L151
1341:stk500boot.c  **** 		{
1342:stk500boot.c  **** 			sendchar(theChar);
 2301               		.loc 1 1342 4 is_stmt 1 view .LVU642
 2302 007e 0E94 0000 		call sendchar
 2303               	.LVL190:
1343:stk500boot.c  **** 		}
1344:stk500boot.c  **** 		ii++;
 2304               		.loc 1 1344 3 view .LVU643
1337:stk500boot.c  **** 	{
 2305               		.loc 1 1337 8 view .LVU644
 2306 0082 00C0      		rjmp .L153
 2307               	.LVL191:
 2308               	.L151:
 2309               	/* epilogue start */
1345:stk500boot.c  **** 	}
1346:stk500boot.c  **** }
 2310               		.loc 1 1346 1 is_stmt 0 view .LVU645
 2311 0084 DF91      		pop r29
 2312 0086 CF91      		pop r28
 2313               	.LVL192:
 2314               		.loc 1 1346 1 view .LVU646
 2315 0088 0895      		ret
 2316               		.cfi_endproc
 2317               	.LFE20:
 2319               	.global	PrintHexByte
 2321               	PrintHexByte:
 2322               	.LVL193:
 2323               	.LFB21:
1347:stk500boot.c  **** 
1348:stk500boot.c  **** //************************************************************************
1349:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1350:stk500boot.c  **** {
 2324               		.loc 1 1350 1 is_stmt 1 view -0
 2325               		.cfi_startproc
 2326               		.loc 1 1350 1 is_stmt 0 view .LVU648
 2327 008a CF93      		push r28
 2328               	.LCFI6:
 2329               		.cfi_def_cfa_offset 4
 2330               		.cfi_offset 28, -3
 2331               	/* prologue: function */
 2332               	/* frame size = 0 */
 2333               	/* stack size = 1 */
 2334               	.L__stack_usage = 1
 2335 008c C82F      		mov r28,r24
1351:stk500boot.c  **** char	theChar;
 2336               		.loc 1 1351 1 is_stmt 1 view .LVU649
1352:stk500boot.c  **** 
1353:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
 2337               		.loc 1 1353 2 view .LVU650
 2338               		.loc 1 1353 17 is_stmt 0 view .LVU651
 2339 008e 982F      		mov r25,r24
 2340 0090 9295      		swap r25
 2341 0092 9F70      		andi r25,lo8(15)
 2342               		.loc 1 1353 10 view .LVU652
 2343 0094 80E3      		ldi r24,lo8(48)
 2344               	.LVL194:
 2345               		.loc 1 1353 10 view .LVU653
 2346 0096 890F      		add r24,r25
 2347               	.LVL195:
1354:stk500boot.c  **** 	if (theChar > 0x39)
 2348               		.loc 1 1354 2 is_stmt 1 view .LVU654
 2349               		.loc 1 1354 5 is_stmt 0 view .LVU655
 2350 0098 8A33      		cpi r24,lo8(58)
 2351 009a 00F0      		brlo .L155
1355:stk500boot.c  **** 	{
1356:stk500boot.c  **** 		theChar	+=	7;
 2352               		.loc 1 1356 3 is_stmt 1 view .LVU656
 2353               		.loc 1 1356 11 is_stmt 0 view .LVU657
 2354 009c 87E3      		ldi r24,lo8(55)
 2355               	.LVL196:
 2356               		.loc 1 1356 11 view .LVU658
 2357 009e 890F      		add r24,r25
 2358               	.LVL197:
 2359               	.L155:
1357:stk500boot.c  **** 	}
1358:stk500boot.c  **** 	sendchar(theChar );
 2360               		.loc 1 1358 2 is_stmt 1 view .LVU659
 2361 00a0 0E94 0000 		call sendchar
 2362               	.LVL198:
1359:stk500boot.c  **** 
1360:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
 2363               		.loc 1 1360 2 view .LVU660
 2364               		.loc 1 1360 28 is_stmt 0 view .LVU661
 2365 00a4 CF70      		andi r28,lo8(15)
 2366               	.LVL199:
 2367               		.loc 1 1360 10 view .LVU662
 2368 00a6 80E3      		ldi r24,lo8(48)
 2369 00a8 8C0F      		add r24,r28
 2370               	.LVL200:
1361:stk500boot.c  **** 	if (theChar > 0x39)
 2371               		.loc 1 1361 2 is_stmt 1 view .LVU663
 2372               		.loc 1 1361 5 is_stmt 0 view .LVU664
 2373 00aa 8A33      		cpi r24,lo8(58)
 2374 00ac 00F0      		brlo .L156
1362:stk500boot.c  **** 	{
1363:stk500boot.c  **** 		theChar	+=	7;
 2375               		.loc 1 1363 3 is_stmt 1 view .LVU665
 2376               		.loc 1 1363 11 is_stmt 0 view .LVU666
 2377 00ae 87E3      		ldi r24,lo8(55)
 2378               	.LVL201:
 2379               		.loc 1 1363 11 view .LVU667
 2380 00b0 8C0F      		add r24,r28
 2381               	.LVL202:
 2382               	.L156:
1364:stk500boot.c  **** 	}
1365:stk500boot.c  **** 	sendchar(theChar );
 2383               		.loc 1 1365 2 is_stmt 1 view .LVU668
 2384               	/* epilogue start */
1366:stk500boot.c  **** }
 2385               		.loc 1 1366 1 is_stmt 0 view .LVU669
 2386 00b2 CF91      		pop r28
1365:stk500boot.c  **** }
 2387               		.loc 1 1365 2 view .LVU670
 2388 00b4 0C94 0000 		jmp sendchar
 2389               	.LVL203:
1365:stk500boot.c  **** }
 2390               		.loc 1 1365 2 view .LVU671
 2391               		.cfi_endproc
 2392               	.LFE21:
 2394               	.global	PrintDecInt
 2396               	PrintDecInt:
 2397               	.LVL204:
 2398               	.LFB22:
1367:stk500boot.c  **** 
1368:stk500boot.c  **** //************************************************************************
1369:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1370:stk500boot.c  **** {
 2399               		.loc 1 1370 1 is_stmt 1 view -0
 2400               		.cfi_startproc
 2401               		.loc 1 1370 1 is_stmt 0 view .LVU673
 2402 00b8 0F93      		push r16
 2403               	.LCFI7:
 2404               		.cfi_def_cfa_offset 4
 2405               		.cfi_offset 16, -3
 2406 00ba 1F93      		push r17
 2407               	.LCFI8:
 2408               		.cfi_def_cfa_offset 5
 2409               		.cfi_offset 17, -4
 2410 00bc CF93      		push r28
 2411               	.LCFI9:
 2412               		.cfi_def_cfa_offset 6
 2413               		.cfi_offset 28, -5
 2414 00be DF93      		push r29
 2415               	.LCFI10:
 2416               		.cfi_def_cfa_offset 7
 2417               		.cfi_offset 29, -6
 2418               	/* prologue: function */
 2419               	/* frame size = 0 */
 2420               	/* stack size = 4 */
 2421               	.L__stack_usage = 4
 2422 00c0 EC01      		movw r28,r24
 2423 00c2 8B01      		movw r16,r22
1371:stk500boot.c  **** int	theChar;
 2424               		.loc 1 1371 1 is_stmt 1 view .LVU674
1372:stk500boot.c  **** int	myNumber;
 2425               		.loc 1 1372 1 view .LVU675
1373:stk500boot.c  **** 
1374:stk500boot.c  **** 	myNumber	=	theNumber;
 2426               		.loc 1 1374 2 view .LVU676
 2427               	.LVL205:
1375:stk500boot.c  **** 
1376:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 2428               		.loc 1 1376 2 view .LVU677
 2429               		.loc 1 1376 5 is_stmt 0 view .LVU678
 2430 00c4 8536      		cpi r24,101
 2431 00c6 9105      		cpc r25,__zero_reg__
 2432 00c8 04F4      		brge .L158
 2433               		.loc 1 1376 23 discriminator 1 view .LVU679
 2434 00ca 6330      		cpi r22,3
 2435 00cc 7105      		cpc r23,__zero_reg__
 2436 00ce 04F0      		brlt .L159
 2437               	.L158:
1377:stk500boot.c  **** 	{
1378:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
 2438               		.loc 1 1378 3 is_stmt 1 view .LVU680
 2439               	.LVL206:
1379:stk500boot.c  **** 		sendchar(theChar );
 2440               		.loc 1 1379 3 view .LVU681
1378:stk500boot.c  **** 		sendchar(theChar );
 2441               		.loc 1 1378 30 is_stmt 0 view .LVU682
 2442 00d0 CE01      		movw r24,r28
 2443               	.LVL207:
1378:stk500boot.c  **** 		sendchar(theChar );
 2444               		.loc 1 1378 30 view .LVU683
 2445 00d2 64E6      		ldi r22,lo8(100)
 2446 00d4 70E0      		ldi r23,0
 2447               	.LVL208:
1378:stk500boot.c  **** 		sendchar(theChar );
 2448               		.loc 1 1378 30 view .LVU684
 2449 00d6 0E94 0000 		call __divmodhi4
 2450               	.LVL209:
 2451               		.loc 1 1379 3 view .LVU685
 2452 00da 80E3      		ldi r24,lo8(48)
 2453 00dc 860F      		add r24,r22
 2454 00de 0E94 0000 		call sendchar
 2455               	.LVL210:
 2456               	.L159:
1380:stk500boot.c  **** 	}
1381:stk500boot.c  **** 
1382:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 2457               		.loc 1 1382 2 is_stmt 1 view .LVU686
 2458               		.loc 1 1382 5 is_stmt 0 view .LVU687
 2459 00e2 CB30      		cpi r28,11
 2460 00e4 D105      		cpc r29,__zero_reg__
 2461 00e6 04F4      		brge .L160
 2462               		.loc 1 1382 22 discriminator 1 view .LVU688
 2463 00e8 0230      		cpi r16,2
 2464 00ea 1105      		cpc r17,__zero_reg__
 2465 00ec 04F0      		brlt .L161
 2466               	.L160:
1383:stk500boot.c  **** 	{
1384:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
 2467               		.loc 1 1384 3 is_stmt 1 view .LVU689
 2468               	.LVL211:
1385:stk500boot.c  **** 		sendchar(theChar );
 2469               		.loc 1 1385 3 view .LVU690
1384:stk500boot.c  **** 		sendchar(theChar );
 2470               		.loc 1 1384 32 is_stmt 0 view .LVU691
 2471 00ee CE01      		movw r24,r28
 2472 00f0 64E6      		ldi r22,lo8(100)
 2473 00f2 70E0      		ldi r23,0
 2474 00f4 0E94 0000 		call __divmodhi4
1384:stk500boot.c  **** 		sendchar(theChar );
 2475               		.loc 1 1384 39 view .LVU692
 2476 00f8 6AE0      		ldi r22,lo8(10)
 2477 00fa 70E0      		ldi r23,0
 2478 00fc 0E94 0000 		call __divmodhi4
 2479               		.loc 1 1385 3 view .LVU693
 2480 0100 80E3      		ldi r24,lo8(48)
 2481 0102 860F      		add r24,r22
 2482 0104 0E94 0000 		call sendchar
 2483               	.LVL212:
 2484               	.L161:
1386:stk500boot.c  **** 	}
1387:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
 2485               		.loc 1 1387 2 is_stmt 1 view .LVU694
1388:stk500boot.c  **** 	sendchar(theChar );
 2486               		.loc 1 1388 2 view .LVU695
1387:stk500boot.c  **** 	sendchar(theChar );
 2487               		.loc 1 1387 29 is_stmt 0 view .LVU696
 2488 0108 CE01      		movw r24,r28
 2489 010a 6AE0      		ldi r22,lo8(10)
 2490 010c 70E0      		ldi r23,0
 2491 010e 0E94 0000 		call __divmodhi4
 2492               		.loc 1 1388 2 view .LVU697
 2493 0112 805D      		subi r24,lo8(-(48))
 2494               	/* epilogue start */
1389:stk500boot.c  **** }
 2495               		.loc 1 1389 1 view .LVU698
 2496 0114 DF91      		pop r29
 2497 0116 CF91      		pop r28
 2498               	.LVL213:
 2499               		.loc 1 1389 1 view .LVU699
 2500 0118 1F91      		pop r17
 2501 011a 0F91      		pop r16
 2502               	.LVL214:
1388:stk500boot.c  **** 	sendchar(theChar );
 2503               		.loc 1 1388 2 view .LVU700
 2504 011c 0C94 0000 		jmp sendchar
 2505               	.LVL215:
 2506               		.cfi_endproc
 2507               	.LFE22:
 2509               		.section	.rodata
 2512               	CSWTCH.24:
 2513 0000 0F        		.byte	15
 2514 0001 02        		.byte	2
 2515 0002 0A        		.byte	10
 2516               	.global	gTextMsg_CPU_Name
 2517               		.section	.progmem.data,"a",@progbits
 2520               	gTextMsg_CPU_Name:
 2521 0000 4154 6D65 		.string	"ATmega2560"
 2521      6761 3235 
 2521      3630 00
 2522               	.global	gEepromIndex
 2523               		.section .bss
 2526               	gEepromIndex:
 2527 0000 0000 0000 		.zero	4
 2528               	.global	gFlashIndex
 2531               	gFlashIndex:
 2532 0004 0000 0000 		.zero	4
 2533               	.global	gRamIndex
 2536               	gRamIndex:
 2537 0008 0000 0000 		.zero	4
 2538               	.global	check
 2539               		.data
 2542               	check:
 2543 0000 01        		.byte	1
 2544               	.global	app_start
 2545               		.section .bss
 2548               	app_start:
 2549 000c 0000      		.zero	2
 2550               	.global	Buff
 2553               	Buff:
 2554 000e 0000 0000 		.zero	256
 2554      0000 0000 
 2554      0000 0000 
 2554      0000 0000 
 2554      0000 0000 
 2555               	.global	Fatfs
 2558               	Fatfs:
 2559 010e 0000 0000 		.zero	42
 2559      0000 0000 
 2559      0000 0000 
 2559      0000 0000 
 2559      0000 0000 
 2560               		.text
 2561               	.Letext0:
 2562               		.file 3 "/usr/avr/include/stdint.h"
 2563               		.file 4 "integer.h"
 2564               		.file 5 "pff.h"
 2565               		.file 6 "/usr/avr/include/avr/eeprom.h"
 2566               		.file 7 "/usr/avr/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccmYnwg8.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccmYnwg8.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccmYnwg8.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccmYnwg8.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccmYnwg8.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccmYnwg8.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccmYnwg8.s:12     .text:0000000000000000 sendchar
     /tmp/ccmYnwg8.s:50     .init9:0000000000000000 __jumpMain
     /tmp/ccmYnwg8.s:61     *ABS*:00000000000021ff __stack
     /tmp/ccmYnwg8.s:166    .text.startup:0000000000000000 main
     /tmp/ccmYnwg8.s:100    .text:0000000000000018 delay_ms
     /tmp/ccmYnwg8.s:2548   .bss:000000000000000c app_start
     /tmp/ccmYnwg8.s:2558   .bss:000000000000010e Fatfs
     /tmp/ccmYnwg8.s:2553   .bss:000000000000000e Buff
     /tmp/ccmYnwg8.s:2542   .data:0000000000000000 check
     /tmp/ccmYnwg8.s:2512   .rodata:0000000000000000 CSWTCH.24
     /tmp/ccmYnwg8.s:2149   .text:0000000000000036 PrintFromPROGMEM
     /tmp/ccmYnwg8.s:2225   .text:000000000000005e PrintNewLine
     /tmp/ccmYnwg8.s:2246   .text:000000000000006a PrintFromPROGMEMln
     /tmp/ccmYnwg8.s:2266   .text:0000000000000072 PrintString
     /tmp/ccmYnwg8.s:2321   .text:000000000000008a PrintHexByte
     /tmp/ccmYnwg8.s:2396   .text:00000000000000b8 PrintDecInt
     /tmp/ccmYnwg8.s:2520   .progmem.data:0000000000000000 gTextMsg_CPU_Name
     /tmp/ccmYnwg8.s:2526   .bss:0000000000000000 gEepromIndex
     /tmp/ccmYnwg8.s:2531   .bss:0000000000000004 gFlashIndex
     /tmp/ccmYnwg8.s:2536   .bss:0000000000000008 gRamIndex

UNDEFINED SYMBOLS
eeprom_read_byte
pf_mount
pf_open
flash_erase
memset
pf_read
flash_write
eeprom_write_byte
__udivmodsi4
__bswapsi2
__divmodhi4
__do_copy_data
__do_clear_bss
